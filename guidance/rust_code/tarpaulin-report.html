<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","constants.rs"],"content":"// Radius used to check if the robot is on the graph (m)\npub const ROBOT_RADIUS: f64 = 1.5;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","error","mod.rs"],"content":"use crate::states::States;\n\n#[derive(PartialEq, Debug)]\npub enum Error {\n    WaitingSubSystem,\n    PathPlanningPathDoesNotExist,\n    PathPlanningNotOnMap,\n    PathPlanningEdgeIndexNotInConnectionMatrix,\n}\n\nimpl Error {\n    pub fn handle(\u0026self) -\u003e Result\u003cStates, Error\u003e {\n        unimplemented!();\n    }\n}\n","traces":[{"line":12,"address":[4283312],"length":1,"stats":{"Line":0},"fn_name":"handle"}],"covered":0,"coverable":1},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","graph","conversions.rs"],"content":"use super::{Edges, GPSPointDeg, GPSPointRad, Graph, TangentialPoint, Vertices};\nuse geojson::{feature::Id, Feature, FeatureCollection, Geometry, Value};\nuse nalgebra::{Matrix3, Vector3};\n\n// Distance from the earth relative to the equator (m)\nconst RO: f64 = 6_378_137.0;\n\n// Ecentricity of the earth (unitless?)\nconst E: f64 = 0.0818;\n\n// Front entrance of king\nconst ORIGIN: GPSPointDeg = GPSPointDeg {\n    lat: 34.614_797_9,\n    long: -112.450_961_5,\n    height: 1582.3,\n};\n\npub fn geo_json_string\u003cT\u003e(elements: T, graph: \u0026Graph) -\u003e String\nwhere\n    T: Edges + Vertices,\n{\n    // Allocating Memory\n    let number_of_vertices_and_edges = elements.edges(graph).len() + elements.vertices(graph).len();\n    let mut features = Vec::with_capacity(number_of_vertices_and_edges);\n\n    for edge in elements.edges(graph).iter() {\n        let edge_points = edge\n            .points\n            .iter()\n            .map(|point| vec![point.gps.long, point.gps.lat])\n            .collect();\n\n        let geometry = Geometry::new(Value::LineString(edge_points));\n\n        let feature = Feature {\n            bbox: None,\n            geometry: Some(geometry),\n            id: Some(Id::String(edge.name.clone())),\n            properties: None,\n            foreign_members: None,\n        };\n\n        features.push(feature);\n    }\n\n    for vertex in elements.vertices(graph).iter() {\n        let vertex_point = vec![vertex.point.gps.long, vertex.point.gps.lat];\n\n        let geometry = Geometry::new(Value::Point(vertex_point));\n\n        let feature = Feature {\n            bbox: None,\n            geometry: Some(geometry),\n            id: Some(Id::String(vertex.name.clone())),\n            properties: None,\n            foreign_members: None,\n        };\n\n        features.push(feature);\n    }\n\n    let feature_collection = FeatureCollection {\n        bbox: None,\n        features,\n        foreign_members: None,\n    };\n\n    feature_collection.to_string()\n}\n\npub trait IntoTangential {\n    type Output;\n\n    fn into_tangential(\u0026self) -\u003e Self::Output;\n}\n\nimpl IntoTangential for GPSPointDeg {\n    type Output = TangentialPoint;\n\n    fn into_tangential(\u0026self) -\u003e TangentialPoint {\n        let origin = ORIGIN.to_rad();\n\n        // vector from center of the earth to an arbitrary point on the map\n        let r_ek_e = self.to_rad().to_xyz();\n\n        // vector from the center of the earth to the origin of our tangential frame\n        let r_eb_e = origin.to_xyz();\n\n        // Vector that goes from origin to an arbitrary point of the map.\n        // Still being expressed in terms of a rectangular frame with its origin at the center of\n        // the earth.\n        let r_kb_e = r_eb_e - r_ek_e;\n\n        // The transformation matrix that converts the basis or our coordinate system\n        let c_e_k = Matrix3::new(\n            -(self.to_rad().long.cos() * self.to_rad().lat.sin()),\n            -origin.long.sin(),\n            -(origin.lat.cos() * origin.long.cos()),\n            -(origin.lat.sin() * origin.long.sin()),\n            origin.long.cos(),\n            -(origin.lat.cos() * origin.long.sin()),\n            origin.lat.cos(),\n            0.0,\n            -origin.lat.sin(),\n        )\n        .try_inverse()\n        .unwrap();\n\n        let result = c_e_k * r_kb_e;\n\n        TangentialPoint { vector: result }\n    }\n}\n\nimpl GPSPointDeg {\n    /// Converts the GPS from degrees to radians\n    fn to_rad(\u0026self) -\u003e GPSPointRad {\n        GPSPointRad {\n            lat: self.lat.to_radians(),\n            long: self.long.to_radians(),\n            height: self.height,\n        }\n    }\n}\n\nimpl GPSPointRad {\n    /// Converts spherical cords to rectangular\n    fn to_xyz(\u0026self) -\u003e Vector3\u003cf64\u003e {\n        // The distance from the center of the earth relative to where you are (m)\n        let re = RO / (1.0 - self.lat.sin().powi(2) * E.powi(2)).sqrt();\n\n        Vector3::new(\n            (re + self.height) * self.lat.cos() * self.long.cos(),\n            (re + self.height) * self.lat.cos() * self.long.sin(),\n            ((re + re * E.powi(2)) + self.height) * self.lat.sin(),\n        )\n    }\n}\n","traces":[{"line":18,"address":[4641124,4641040],"length":1,"stats":{"Line":1},"fn_name":"geo_json_string\u003c\u0026rust_code::graph::Graph\u003e"},{"line":23,"address":[4641066,4641188,4641147,4644019],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4641335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4642571,4641394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4641676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4644193,4644176],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003c\u0026rust_code::graph::Graph\u003e"},{"line":33,"address":[4641808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4641923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4642123,4642180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4642532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4642600,4643670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4642855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4642910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4643025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4643279,4643222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4643631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4643851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4265536],"length":1,"stats":{"Line":1},"fn_name":"into_tangential"},{"line":81,"address":[4265554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4265604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4265646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4265667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4265792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4265925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[4265992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4266077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4266162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4266188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4266267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4266293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4266477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4266704],"length":1,"stats":{"Line":1},"fn_name":"to_rad"},{"line":119,"address":[4266716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4266751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4266772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4266832],"length":1,"stats":{"Line":1},"fn_name":"to_xyz"},{"line":130,"address":[4266850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4267025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[4267150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4267258],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":40},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","graph","mod.rs"],"content":"use std::f64;\nuse std::fs::File;\nuse std::io::BufReader;\nuse std::ops::{Mul, Sub};\n\nuse conversions::IntoTangential;\nuse gpx;\nuse nalgebra::{DMatrix, Vector3};\n\npub mod conversions;\n\npub type EdgeIndex = usize;\npub type VertexIndex = usize;\n\n// Clone trait only for unit testing\n#[derive(Debug, Clone, PartialEq)]\npub struct Point {\n    pub gps: GPSPointDeg,\n    pub tangential: TangentialPoint,\n}\n\n// Clone Trait only for unit testing\n#[derive(Debug, PartialEq, Clone, Copy)]\npub struct TangentialPoint {\n    vector: Vector3\u003cf64\u003e,\n}\n\nimpl Sub for \u0026TangentialPoint {\n    type Output = TangentialPoint;\n\n    fn sub(self, other: Self) -\u003e TangentialPoint {\n        TangentialPoint {\n            vector: self.vector - other.vector,\n        }\n    }\n}\n\nimpl Mul\u003cf64\u003e for TangentialPoint {\n    type Output = Self;\n\n    fn mul(self, rhs: f64) -\u003e Self::Output {\n        TangentialPoint {\n            vector: self.vector * rhs,\n        }\n    }\n}\n\nimpl TangentialPoint {\n    pub fn new(x: f64, y: f64, z: f64) -\u003e Self {\n        TangentialPoint {\n            vector: Vector3::new(x, y, z),\n        }\n    }\n    pub fn x(\u0026self) -\u003e f64 {\n        self.vector[0]\n    }\n    pub fn y(\u0026self) -\u003e f64 {\n        self.vector[1]\n    }\n    pub fn z(\u0026self) -\u003e f64 {\n        self.vector[2]\n    }\n    pub fn distance(\u0026self, other: \u0026Self) -\u003e f64 {\n        let point = other - self;\n\n        (point.x().powi(2) + point.y().powi(2) + point.z().powi(2)).sqrt()\n    }\n}\n\n// Clone trait only for unit testing\n#[derive(Debug, Clone)]\npub struct GPSPointDeg {\n    pub lat: f64,\n    pub long: f64,\n    pub height: f64,\n}\n\nimpl PartialEq for GPSPointDeg {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.lat == other.lat \u0026\u0026 self.long == other.long\n    }\n}\n\npub(self) struct GPSPointRad {\n    pub(self) lat: f64,\n    pub(self) long: f64,\n    pub(self) height: f64,\n}\n\n#[derive(Debug, PartialEq)]\npub struct Edge {\n    // For debugging, finding out what line we are looking at on the map\n    pub name: String,\n\n    // T, in this case, can be a point relative to our tangential frame, or the gps frame\n    pub points: Vec\u003cPoint\u003e,\n\n    pub distance: f64,\n}\n\nimpl Edge {\n    fn new(name: String, points: Vec\u003cPoint\u003e) -\u003e Self {\n        // Determining the distance of the edge for construction\n        let mut distance = 0.0;\n\n        let points_n = points.iter().map(|point| \u0026point.tangential);\n        let mut points_n_plus_1 = points.iter().map(|point| \u0026point.tangential);\n        points_n_plus_1.next();\n\n        // Combines the iterator of point_n and point_n_plus_one iterator into a single iterator so if may be consumed\n        // in the for loop.\n        let points_n_n_plus_1 = points_n.zip(points_n_plus_1);\n\n        for (point_n, points_n_plus_1) in points_n_n_plus_1 {\n            distance += point_n.distance(\u0026points_n_plus_1);\n        }\n\n        Edge {\n            name,\n            points,\n            distance,\n        }\n    }\n}\n\npub trait Edges {\n    fn edges\u003c'edge, 'graph\u003e(\u0026'edge self, graph: \u0026'graph Graph) -\u003e Vec\u003c\u0026'graph Edge\u003e;\n}\n\n#[derive(Debug, PartialEq)]\n// A is a lifetime\npub struct Vertex {\n    // Will be used to display key locations to UI\n    pub name: String,\n\n    // Will be used to identify adjacent nodes and edges. T will be either a GPSPoint or a point\n    // in our tangential frame.\n    pub(self) point: Point,\n\n    // Key data to determine the shortest path using Dijkstra's Algorithm\n    pub parent_vertex_index: Option\u003cVertexIndex\u003e,\n    pub tentative_distance: f64,\n    pub visited: bool,\n}\n\nimpl Vertex {\n    fn new(name: String, gps: GPSPointDeg) -\u003e Vertex {\n        let tangential = gps.into_tangential();\n\n        let point = Point { gps, tangential };\n\n        Vertex {\n            name,\n            point,\n            parent_vertex_index: None,\n            tentative_distance: f64::MAX,\n            visited: false,\n        }\n    }\n}\n\n// Element at a matrix_index[i][j] indicates an Edge Index\n#[derive(Debug, PartialEq)]\npub struct MatrixIndex {\n    pub ith: VertexIndex,\n    pub jth: VertexIndex,\n}\n\nimpl MatrixIndex {\n    pub fn edge\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e \u0026'b Edge {\n        let edge_index = graph.connection_matrix[(self.ith, self.jth)].unwrap();\n        \u0026graph.edges[edge_index]\n    }\n\n    pub fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e (\u0026'b Vertex, \u0026'b Vertex) {\n        let (index_1, index_2) = (self.ith, self.jth);\n\n        (\u0026graph.vertices[index_1], \u0026graph.vertices[index_2])\n    }\n}\n\npub trait Vertices {\n    fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Vertex\u003e;\n}\n\npub struct Graph {\n    pub vertices: Vec\u003cVertex\u003e,\n    pub edges: Vec\u003cEdge\u003e,\n    pub connection_matrix: DMatrix\u003cOption\u003cEdgeIndex\u003e\u003e,\n}\n\nimpl Vertices for \u0026Graph {\n    fn vertices\u003c'vertex, 'graph\u003e(\u0026'vertex self, graph: \u0026'graph Graph) -\u003e Vec\u003c\u0026'graph Vertex\u003e {\n        graph.vertices.iter().collect()\n    }\n}\n\nimpl Edges for \u0026Graph {\n    fn edges\u003c'edge, 'graph\u003e(\u0026'edge self, graph: \u0026'graph Graph) -\u003e Vec\u003c\u0026'graph Edge\u003e {\n        graph.edges.iter().collect()\n    }\n}\n\npub(self) fn connect_vertices_with_edges(edges: Vec\u003cEdge\u003e, vertices: Vec\u003cVertex\u003e) -\u003e Graph {\n    let vertices_len = vertices.len();\n\n    let mut connection_matrix = DMatrix::from_vec(\n        vertices_len,                            // number of rows\n        vertices_len,                            // number of columns\n        vec![None; vertices_len * vertices_len], // initializing the array to None\n    );\n\n    // Iterating though all edges and vertices. When the first and last point of an edge match two vertices, then the\n    // connection matrix at v_m v_n and v_n v_m gets populated with the index to the edges vector.\n    for (edge_index, edge) in edges.iter().enumerate() {\n        let start_of_edge = edge.points.first().unwrap();\n        let end_of_edge = edge.points.last().unwrap();\n        let mut start_vertex_index = None;\n        let mut end_vertex_index = None;\n\n        for (vertex_index, vertex) in vertices.iter().enumerate() {\n            if vertex.point.gps == start_of_edge.gps {\n                start_vertex_index = Some(vertex_index);\n            } else if vertex.point.gps == end_of_edge.gps {\n                end_vertex_index = Some(vertex_index);\n            }\n        }\n\n        match (start_vertex_index, end_vertex_index) {\n            // If the start and end vertices have been assigned then we know the edge that connects those two vertices.\n            // The connection matrix should be updated to reflex that we know the edge and is associated vertices.\n            (Some(start_vertex_index), Some(end_vertex_index)) =\u003e {\n                connection_matrix[(start_vertex_index, end_vertex_index)] = Some(edge_index);\n                connection_matrix[(end_vertex_index, start_vertex_index)] = Some(edge_index);\n            }\n\n            // If either one of them didn't get assigned, panic with some helpful information.\n            _ =\u003e panic!(\"{} is dangling in the gpx file\", edge.name),\n        };\n    }\n\n    Graph {\n        edges,\n        vertices,\n        connection_matrix,\n    }\n}\n\npub fn initialize_from_gpx_file(name: \u0026str) -\u003e Graph {\n    // Open file and read contents to memory\n    let file = File::open(name).unwrap();\n    let reader = BufReader::new(file);\n\n    let gpx_data = gpx::read(reader).unwrap();\n\n    let vertices = gpx_data\n        .waypoints\n        .into_iter()\n        .map(|vertex_data| {\n            // long, lat order is intentional. They are stored in this order in the file.\n            let (long, lat) = vertex_data.point().x_y();\n\n            let height = vertex_data.elevation.unwrap();\n            let name = vertex_data.name.unwrap();\n\n            Vertex::new(name, GPSPointDeg { long, lat, height })\n        })\n        .collect::\u003cVec\u003cVertex\u003e\u003e();\n\n    let edges = gpx_data\n        .tracks\n        .into_iter()\n        .map(|track| {\n            // Indexing at 0 since for every track we are guaranteed to only have move segment.\n            let points = track.segments[0]\n                .points\n                .iter()\n                .map(|waypoint| {\n                    let height = waypoint.elevation.unwrap();\n                    let (long, lat) = waypoint.point().x_y();\n                    let gps = GPSPointDeg { long, lat, height };\n                    let tangential = gps.into_tangential();\n\n                    Point { gps, tangential }\n                })\n                .collect::\u003cVec\u003cPoint\u003e\u003e();\n\n            let name = track.name.unwrap();\n\n            Edge::new(name, points)\n        })\n        .collect::\u003cVec\u003cEdge\u003e\u003e();\n\n    let graph = connect_vertices_with_edges(edges, vertices);\n\n    graph\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":31,"address":[4267424],"length":1,"stats":{"Line":1},"fn_name":"sub"},{"line":33,"address":[4267441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4267568],"length":1,"stats":{"Line":1},"fn_name":"mul"},{"line":43,"address":[4267581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4267680],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":51,"address":[4267705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4267776],"length":1,"stats":{"Line":1},"fn_name":"x"},{"line":55,"address":[4267796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4267824],"length":1,"stats":{"Line":1},"fn_name":"y"},{"line":58,"address":[4267840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4267872],"length":1,"stats":{"Line":1},"fn_name":"z"},{"line":61,"address":[4267888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4267920],"length":1,"stats":{"Line":1},"fn_name":"distance"},{"line":64,"address":[4267934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4267957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4268144],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":80,"address":[4268158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4268240,4268317],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":104,"address":[4268250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4222288,4222301],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":107,"address":[4222333,4222320],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":108,"address":[4268579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4268586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4269006,4268627,4269118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[4269072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4269152,4269200],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":148,"address":[4269172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4269228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[4269664],"length":1,"stats":{"Line":1},"fn_name":"edge"},{"line":171,"address":[4269685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4269806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[4269856],"length":1,"stats":{"Line":1},"fn_name":"vertices"},{"line":176,"address":[4269877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4269914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[4270016],"length":1,"stats":{"Line":1},"fn_name":"vertices"},{"line":194,"address":[4270038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4270128],"length":1,"stats":{"Line":1},"fn_name":"edges"},{"line":200,"address":[4270145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[4270240,4270300],"length":1,"stats":{"Line":1},"fn_name":"connect_vertices_with_edges"},{"line":205,"address":[4270323,4270258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[4270331,4270408,4272504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4270498,4272388,4270602,4271056],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[4271122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4271256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[4271363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4271375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4271709,4271985,4271395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[4271775,4271912,4271983],"length":1,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[4271860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[4271918,4271829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[4271931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4271625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[4271689,4272081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[4272132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[4272273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[4271990,4272398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4272560,4272627],"length":1,"stats":{"Line":1},"fn_name":"initialize_from_gpx_file"},{"line":251,"address":[4272586,4272649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4272673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[4272687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[4272778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4222352,4222427],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":261,"address":[4222454,4222370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[4222520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4222579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[4222637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4272887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4223776,4223887],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":275,"address":[4223902,4223794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[4223408],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":279,"address":[4223441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[4223496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[4223571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4223595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[4223610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[4224008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[4224016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4224079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[4272996],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":79},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","graph","tests.rs"],"content":"use crate::graph;\nuse crate::graph::conversions::{geo_json_string, IntoTangential};\nuse crate::graph::*;\n\n#[test]\nfn initialize_from_gpx_file_test_triangle() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Triangle.gpx\");\n\n    // Asserting the the diagonal of the matrix is none, meaning that no vertex has an edge that\n    // connects to itself. Anything not along the diagonal of the matrix should be populated with a\n    // value in this specific case.\n    for row in 0..graph.connection_matrix.nrows() {\n        for column in 0..graph.connection_matrix.ncols() {\n            if row == column {\n                assert_eq!(graph.connection_matrix[(row, column)], None);\n            } else {\n                assert_ne!(graph.connection_matrix[(row, column)], None);\n            }\n        }\n    }\n}\n\n#[test]\nfn full_graph_no_dangling_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Full School Map.gpx\");\n\n    // Checking that no edge was left unconnected by asserting that the connection matrix is\n    // symmetrical across its diagonal.\n    for row_i in 0..graph.connection_matrix.nrows() {\n        for col_i in 0..graph.connection_matrix.ncols() {\n            if graph.connection_matrix[(row_i, col_i)].is_some() {\n                assert!(graph.connection_matrix[(col_i, row_i)].is_some())\n            }\n        }\n    }\n}\n\n#[test]\nfn initialize_from_gpx_file_single_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n\n    let edges = \u0026graph.edges;\n    let edge = \u0026edges[0];\n\n    assert_eq!(edges.len(), 1);\n    assert_eq!(edge.points.len(), 3);\n    assert_eq!(edge.points[0].gps.long, -112.4484608);\n    assert_eq!(edge.points[0].gps.lat, 34.615871);\n    assert_eq!(edge.points[1].gps.long, -112.4484635);\n    assert_eq!(edge.points[1].gps.lat, 34.6157165);\n    assert_eq!(edge.points[2].gps.long, -112.4484742);\n    assert_eq!(edge.points[2].gps.lat, 34.6155377);\n}\n\n#[test]\nfn graph_to_geo_json_string() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n\n    let json_string = geo_json_string(\u0026graph, \u0026graph);\n    let expected_json_string = r#\"{\"features\":[{\"geometry\":{\"coordinates\":[[-112.4484608,34.615871],[-112.4484635,34.6157165],[-112.4484742,34.6155377]],\"type\":\"LineString\"},\"id\":\"Line 3\",\"properties\":{},\"type\":\"Feature\"},{\"geometry\":{\"coordinates\":[-112.4484608,34.615871],\"type\":\"Point\"},\"id\":\"Point 1\",\"properties\":{},\"type\":\"Feature\"},{\"geometry\":{\"coordinates\":[-112.4484742,34.6155377],\"type\":\"Point\"},\"id\":\"Point 2\",\"properties\":{},\"type\":\"Feature\"}],\"type\":\"FeatureCollection\"}\"#;\n\n    assert_eq!(json_string, expected_json_string);\n}\n\n#[test]\nfn distance() {\n    let origin = graph::TangentialPoint {\n        vector: Vector3::new(0.0, 0.0, 0.0),\n    };\n\n    let point = graph::TangentialPoint {\n        vector: Vector3::new(1.0, 1.0, 1.0),\n    };\n\n    let distance = origin.distance(\u0026point);\n\n    assert_eq!(distance, 3.0_f64.sqrt());\n}\n\n#[test]\nfn into_tangential() {\n    let king_front_entrance = graph::GPSPointDeg {\n        lat: 34.6147979,\n        long: -112.4509615,\n        height: 1582.3,\n    };\n\n    assert_eq!(\n        king_front_entrance.into_tangential(),\n        graph::TangentialPoint {\n            vector: Vector3::new(0.0, 0.0, 0.0)\n        }\n    )\n}\n\n#[test]\nfn tangential_sub() {\n    let origin = \u0026graph::TangentialPoint {\n        vector: Vector3::new(0.0, 0.0, 0.0),\n    };\n    let point = \u0026graph::TangentialPoint {\n        vector: Vector3::new(1.0, 2.0, 3.0),\n    };\n\n    assert_eq!(\n        point - origin,\n        TangentialPoint {\n            vector: Vector3::new(1.0, 2.0, 3.0)\n        }\n    )\n}\n\n#[test]\nfn graph_into_tangential() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    let origin = graph\n        .vertices\n        .iter()\n        .filter(|vertex| vertex.name.contains(\"King Engineering (Front Entrance)\"))\n        .next()\n        .unwrap();\n\n    assert_eq!(\n        origin.point.tangential,\n        TangentialPoint {\n            vector: Vector3::new(0.0, 0.0, 0.0)\n        }\n    );\n}\n\n#[test]\nfn into_tangential_correct_distances() {\n    let king_start_edge = graph::GPSPointDeg {\n        lat: 34.6147979,\n        long: -112.4509615,\n        height: 1582.341,\n    }\n    .into_tangential();\n\n    let king_end_edge = graph::GPSPointDeg {\n        lat: 34.6148752,\n        long: -112.4509389,\n        height: 1581.907,\n    }\n    .into_tangential();\n\n    // Expected distance is about 8.8382m\n    let distance_between_points = king_end_edge.distance(\u0026king_start_edge);\n\n    assert!(distance_between_points \u003e 8.0 \u0026\u0026 distance_between_points \u003c 9.0);\n}\n\n#[test]\nfn edge_initialization() {\n    let points = vec![\n        Point {\n            tangential: TangentialPoint {\n                vector: Vector3::new(0.0, 0.0, 0.0),\n            },\n            gps: GPSPointDeg {\n                lat: -1.0,\n                long: -1.0,\n                height: -1.0,\n            }, // Unimportant for this test\n        },\n        Point {\n            tangential: TangentialPoint {\n                vector: Vector3::new(1.0, 1.0, 1.0),\n            },\n            gps: GPSPointDeg {\n                lat: -1.0,\n                long: -1.0,\n                height: -1.0,\n            }, // Unimportant for this test\n        },\n    ];\n\n    let name = String::from(\"the slight\");\n\n    assert_eq!(\n        Edge::new(name.clone(), points.clone()),\n        Edge {\n            name,\n            points,\n            distance: 3.0_f64.sqrt()\n        }\n    )\n}\n\n#[test]\nfn edge_from_connection_index() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let matrix_index = MatrixIndex {\n        ith: vertex_index_0,\n        jth: vertex_index_1,\n    };\n\n    assert_eq!(\u0026graph.edges[0], matrix_index.edge(\u0026graph));\n}\n\n#[test]\nfn vertices_from_connection_matrix() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let matrix_index = MatrixIndex { ith: 0, jth: 1 };\n\n    assert_eq!(\n        matrix_index.vertices(\u0026graph),\n        (\u0026graph.vertices[0], \u0026graph.vertices[1])\n    )\n}\n","traces":[{"line":6,"address":[4249893,4249856],"length":1,"stats":{"Line":3},"fn_name":"initialize_from_gpx_file_test_triangle"},{"line":7,"address":[4249870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4250025,4250151,4249908,4250403],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[4250185,4250408,4251535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4250450,4251220,4250755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[4250544,4250760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4251105,4251225,4250463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4251584,4251621],"length":1,"stats":{"Line":3},"fn_name":"full_graph_no_dangling_edge"},{"line":25,"address":[4251598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4251738,4251849,4251636,4252068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[4252073,4251883,4252342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4252310,4252107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4252312,4252211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4224912,4224917],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4252398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4252436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4252452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4252691,4252513,4252551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4253068,4253219,4252666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4253183,4253743,4253596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4253707,4254120,4254262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4254639,4254787,4254225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4255306,4254750,4255164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4255269,4255683,4255831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4256172,4256281,4255794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[4224944,4224949],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":57,"address":[4256638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4256686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4256699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4256836,4256882,4256734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4224976,4224981],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":68,"address":[4257271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4257343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[4257422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4257586,4257457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4225013,4225008],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":88,"address":[4258021,4258116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4257921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4257973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4257939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4225040,4225045],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":98,"address":[4258478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4258423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4258540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4258527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4258817,4258710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4258604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4258662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4258649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4225072,4225077],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":115,"address":[4259118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4259257,4259164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[4225104,4225118],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":124,"address":[4259363,4259445,4259556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4259408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[4259401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4225200,4225205],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":149,"address":[4259926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[4260053,4260023,4259965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[4225232,4225237],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":156,"address":[4260503,4260071,4261459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[4260219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4260153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4260131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[4260195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4260407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[4260332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4260317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4260380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4260615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4261110,4261134,4260971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4260687,4260642,4260734,4261477],"length":1,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[4260884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[4260781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[4260813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[4260853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[4225264,4225269],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":193,"address":[4261678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4261713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[4261725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4261761,4261850,4261974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[4225296,4225301],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":207,"address":[4262334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4262369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[4262380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4262391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4262680,4262575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[4262428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4262471,4262512],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":89,"coverable":89},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","main.rs"],"content":"// remove this once if the state machine ever gets implemented\n#![allow(dead_code)] \nmod constants;\nmod error;\nmod graph;\nmod network;\nmod path_planning;\nmod states;\nmod traversal;\nmod ui;\n\nuse std::fs;\nuse std::io::Read;\nuse std::io::Write;\nuse std::net::{Ipv4Addr, SocketAddrV4, TcpListener};\nuse std::thread;\nuse std::time::Duration;\n\nuse error::Error;\nuse graph::conversions;\nuse states::States;\nuse ui::TO_UI;\n\n\nfn main() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    {\n        TO_UI.lock().unwrap().write_all(b\"hello\").unwrap();\n    } // Curly braces are here to drop the lock to the UI\n\n    // This function will block waiting for nav, control, and image processing.\n    // Blocking will occur in the order listed.\n    let tcp_streams = network::TcpStreams::setup();\n\n    // Writing the graph back to disk for visual confirmation\n    let geo_json_string = conversions::geo_json_string(\u0026graph, \u0026graph);\n\n    fs::write(\"school_map.geojson\", geo_json_string).unwrap();\n\n    // TODO: Communication here\n    let mut current_state: Result\u003cStates, Error\u003e = Ok(States::Wait);\n\n    loop {\n        match current_state {\n            Err(err) =\u003e unimplemented!(),\n            Ok(state) =\u003e match state {\n                States::PlanPath =\u003e unimplemented!(),\n                States::Wait =\u003e unimplemented!(),\n                States::Traverse =\u003e unimplemented!(),\n                States::Shutdown =\u003e break,\n            },\n        }\n    }\n}\n","traces":[{"line":25,"address":[4403120,4403154],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":26,"address":[4403134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4403169,4403220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4403382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4403402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4403415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4403504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4403580,4403520],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","network","mod.rs"],"content":"use std::io::Write;\nuse std::net::{Ipv4Addr, SocketAddrV4};\n\nuse crate::ui::TO_UI;\nuse cfg_if::cfg_if;\n\ncfg_if! {\n\n    // This can be thought of as a #ifdef in c. In this case, if cargo test is run, then compile the\n    // following code contained within the if statement. This mocks networking code reliant on\n    // hardware.\n    if #[cfg(test)] {\n\n        use mockall::*;\n        use std::io::Result;\n        use std::net::{ToSocketAddrs, SocketAddr};\n\n        mock! {\n            pub TcpStream {}\n        }\n\n        use MockTcpStream as TcpStream;\n\n        mock! {\n            pub TcpListener {\n                fn bind\u003cA: ToSocketAddrs + 'static\u003e(addr: A) -\u003e Result\u003cTcpListener\u003e;\n                fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c()\u003e;\n                fn accept(\u0026self) -\u003e Result\u003c(TcpStream, SocketAddr)\u003e;\n            }\n        }\n\n        use MockTcpListener as TcpListener;\n    }\n\n    else {\n        // cargo run or cargo build was supplied to the terminal. Compile the real code.\n        use std::net::{TcpListener, TcpStream};\n    }\n}\n\nconst GUIDANCE_IP: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1);\nconst CONTROL_PORT: u16 = 31401;\nconst NAV_PORT: u16 = 31402;\nconst IMAG_PROC_PORT: u16 = 31403;\n\npub struct TcpStreams {\n    nav: TcpStream,\n    control: TcpStream,\n    imag_proc: TcpStream,\n}\n\nimpl TcpStreams {\n    pub fn setup() -\u003e Self {\n        TcpStreams {\n            nav: establish_connection(SocketAddrV4::new(GUIDANCE_IP, NAV_PORT)),\n            control: establish_connection(SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT)),\n            imag_proc: establish_connection(SocketAddrV4::new(GUIDANCE_IP, IMAG_PROC_PORT)),\n        }\n    }\n}\n\npub(self) fn establish_connection(socket: SocketAddrV4) -\u003e TcpStream {\n    let tcp_listener = match TcpListener::bind(socket) {\n        Ok(tcp_listener) =\u003e tcp_listener,\n        Err(error) =\u003e {\n            let message = format!(\"Unable to bind to socket: {}\", error);\n\n            // Using unwrap since we are guaranteed to get the mutex. Since we only have one thread.\n            let mut to_ui = TO_UI.lock().unwrap();\n\n            to_ui\n                .write_all(message.as_bytes())\n                .expect(\"Failed to send bind failure to UI\");\n\n            // droping ui lock to avoid poison errors in UI test\n            drop(to_ui);\n            panic!(\"{}\", message)\n        }\n    };\n\n    match tcp_listener.accept() {\n        Ok((tcp_stream, _socket_addr)) =\u003e tcp_stream,\n        Err(error) =\u003e {\n            let message = format!(\"Guidance unable to accept: {}\", error);\n            let mut to_ui = TO_UI.lock().unwrap();\n            to_ui // Acquired mutex\n                .write_all(message.as_bytes()) // Sending message to UI\n                .expect(\"Failed to send tcp accept error message to UI\");\n\n            // Dropping the lock to the UI so other tests wont have poison errors\n            drop(to_ui);\n            panic!(message);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":18,"address":[4230624,4230608,4230640,4230641],"length":1,"stats":{"Line":3},"fn_name":"default"},{"line":24,"address":[4895248,4895168,4895405,4895520,4895208,4895232,4895504,4895527,4895200,4895262,4895237,4895185],"length":1,"stats":{"Line":289},"fn_name":"checkpoint"},{"line":26,"address":[4762907,4759355,4759081,4766844,4758937,4767225,4759677],"length":1,"stats":{"Line":10},"fn_name":null},{"line":53,"address":[4227936],"length":1,"stats":{"Line":1},"fn_name":"setup"},{"line":55,"address":[4227940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4227976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4228016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4228141,4228064],"length":1,"stats":{"Line":3},"fn_name":"establish_connection"},{"line":63,"address":[4228277,4228071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4228279,4228156],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[4228171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4228414,4228506,4228187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4228565,4228629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4228778,4228712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4228735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4228819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4228850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4229154,4228391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4229156,4229044],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4229060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4229211,4229309,4229076],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[4229376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4229486,4229544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[4229506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4229585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4229616],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":26},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","network","tests.rs"],"content":"use super::*;\nuse crate::ui::*;\nuse std::io;\nuse std::net::IpAddr;\n\n// Some tests are desgined to panic. Unfortuneately, those tests share a state with the UI and can \n// cause other tests designed not to panic, to panic. To remedy this, we run the non-panicing tests in parrallel,\n// and then run the panicing tests in a single thread using the following command.\n//\n// cargo test -- --ignored --test-threads=1\n//\n// Note: this has a negligible affect on runtime when compared to the time to compile tests.\n#[test]\n#[ignore = \"single threaded only\"]\n#[should_panic]\nfn establish_connection_unable_to_bind() {\n    let mut to_ui = TO_UI.lock().unwrap();\n    to_ui\n        .expect_write()\n        .times(1) // An assertion that the write method to UI was called 1 time.\n        .returning(|_| Ok(0));\n\n    let mock_bind = MockTcpListener::bind_context();\n    mock_bind\n        .expect()\n        // The error returned is arbitrary. Just want to make sure that if there is an error,\n        // we notify the UI and Panic\n        .returning(|_: SocketAddrV4| Err(io::Error::last_os_error()));\n\n    let socket = SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT);\n    let _ = establish_connection(socket);\n}\n\n#[test]\nfn establish_connection_able_to_bind_and_accept() {\n    // Aquiring lock as sycronization for mock bind\n    let _ = TO_UI.lock().unwrap();\n\n    // Making acquring the lock succeed regardless if another thread panics\n    // with the lock. a.k.a poisoning.\n    let mock_bind = MockTcpListener::bind_context();\n\n    mock_bind\n        .expect()\n        // Please ignore the type parameter to the input of returning since it is unused to set the\n        // return.\n        .returning(|_: SocketAddrV4| {\n            let mut mock_tcp_listener = MockTcpListener::new();\n\n            mock_tcp_listener.expect_accept().returning(|| {\n                Ok((\n                    MockTcpStream::new(),\n                    SocketAddr::new(IpAddr::V4(GUIDANCE_IP), CONTROL_PORT),\n                ))\n            });\n\n            Ok(mock_tcp_listener)\n        });\n\n    let socket = SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT);\n\n    establish_connection(socket);\n    // Assertion is this path does not panic\n}\n\n#[test]\n#[ignore = \"single threaded only\"]\n#[should_panic]\nfn establish_connection_unable_to_accept() {\n    let mut to_ui = TO_UI.lock().unwrap();\n    to_ui\n        .expect_write()\n        .times(1) // An assertion that the write method to UI was called 1 time.\n        .returning(|_| Ok(0));\n\n    drop(to_ui);\n\n    let mock_bind = MockTcpListener::bind_context();\n    mock_bind\n        .expect()\n        // Please ignore the type parameter to the input of returning since it is unused to set the\n        // return.\n        .returning(|_: SocketAddrV4| {\n            let mut mock_tcp_listener = MockTcpListener::new();\n\n            mock_tcp_listener\n                .expect_accept()\n                .returning(|| Err(io::Error::last_os_error())); // Return stating non-blocking was successful\n\n            Ok(mock_tcp_listener)\n        });\n\n    let socket = SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT);\n    establish_connection(socket);\n}\n\n\n#[test]\nfn network_setup() {\n    let mut to_ui = TO_UI.lock().unwrap();\n    to_ui\n        .expect_write()\n        .times(0) // Asserting the UI will never be called.\n        .returning(|_| Ok(0));\n\n    let mock_bind = MockTcpListener::bind_context();\n    mock_bind\n        .expect()\n        // Please ignore the type parameter to the input of returning since it is unused to set the\n        // return.\n        .returning(|_: SocketAddrV4| {\n            let mut mock_tcp_listener = MockTcpListener::new();\n\n            mock_tcp_listener.expect_accept().returning(|| {\n                Ok((\n                    MockTcpStream::new(),\n                    SocketAddr::new(IpAddr::V4(GUIDANCE_IP), CONTROL_PORT),\n                ))\n            });\n\n            Ok(mock_tcp_listener)\n        });\n\n    let _tcp_streams = TcpStreams::setup();\n    // Assertion does not panic\n}\n","traces":[{"line":16,"address":[4602672,4602677],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":17,"address":[4479783,4479832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4479863,4479914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4602725,4602704],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":23,"address":[4479938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4479955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4602764,4602752],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":30,"address":[4480010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4480051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4602832,4602837],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":37,"address":[4480183,4480227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4480263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4480278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4603040,4603083],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":48,"address":[4603058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4602864,4603103],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":51,"address":[4602930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4602886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4602891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4603139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4480333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4480374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4480448,4480497],"length":1,"stats":{"Line":4},"fn_name":"establish_connection_unable_to_accept"},{"line":70,"address":[4480512,4480455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[4480551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4603317,4603296],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":76,"address":[4480614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4480639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4480656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4603424,4603467],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":84,"address":[4603442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4603487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4603344,4603356],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":90,"address":[4603523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4480714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4480755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4480912,4480953],"length":1,"stats":{"Line":3},"fn_name":"network_setup"},{"line":100,"address":[4480965,4480919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4480996,4481046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4603701,4603680],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":106,"address":[4481070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4481087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4603904,4603947],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":112,"address":[4603922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4603967,4603728],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":115,"address":[4603794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4603750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4603755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4604003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4481142],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":50},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","path_planning","mod.rs"],"content":"use std::f64;\n\nuse crate::constants::ROBOT_RADIUS;\nuse crate::error::Error;\nuse crate::graph::*;\nuse crate::States;\n\nfn plan_path() -\u003e Result\u003cStates, Error\u003e {\n    // TODO: Send Message to UI\n\n    // TODO: Is robot on edge?\n    unimplemented!();\n}\n\n#[derive(Debug, PartialEq)]\npub struct Path {\n    indices: Vec\u003cMatrixIndex\u003e,\n}\n\nimpl Edges for Path {\n    fn edges\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Edge\u003e {\n        self.indices\n            .iter()\n            .map(|matrix_index| matrix_index.edge(graph))\n            .collect()\n    }\n}\n\nimpl Edges for \u0026Path {\n    fn edges\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Edge\u003e {\n        self.indices\n            .iter()\n            .map(|matrix_index| matrix_index.edge(graph))\n            .collect()\n    }\n}\n\nimpl Vertices for Path {\n    fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Vertex\u003e {\n        // Allocating Memory\n        let mut vertices = Vec::with_capacity(2 * self.indices.len());\n\n        let vertices_start_end = self\n            .indices\n            .iter()\n            .map(|matrix_index| matrix_index.vertices(graph));\n\n        for (vertex_1, vertex_2) in vertices_start_end {\n            vertices.push(vertex_1);\n            vertices.push(vertex_2);\n        }\n\n        // Return the vertex with repeated elements removed\n        vertices.dedup();\n\n        vertices\n    }\n}\n\nimpl Vertices for \u0026Path {\n    fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Vertex\u003e {\n        // Allocating Memory\n        let mut vertices = Vec::with_capacity(2 * self.indices.len());\n\n        let vertices_start_end = self\n            .indices\n            .iter()\n            .map(|matrix_index| matrix_index.vertices(graph));\n\n        for (vertex_1, vertex_2) in vertices_start_end {\n            vertices.push(vertex_1);\n            vertices.push(vertex_2);\n        }\n\n        // Return the vertex with repeated elements removed\n        vertices.dedup();\n\n        vertices\n    }\n}\n\nimpl Graph {\n    /// Returns an error if the robot is not on the edge. Otherwise,\n    /// returns the Matrix index indicating the edge containing the robot.\n    fn closest_edge_to(\u0026self, robot_loc: \u0026TangentialPoint) -\u003e Result\u003cMatrixIndex, Error\u003e {\n        let edges_and_indices = self.edges.iter().enumerate();\n\n        let mut closest_point = TangentialPoint::new(f64::MAX, f64::MAX, f64::MAX);\n        let mut closest_edge_index = None;\n\n        for (edge_index, edge) in edges_and_indices {\n            let point_n = edge.points.iter();\n            let mut point_n_plus_1 = edge.points.iter();\n            point_n_plus_1.next();\n\n            let steps = 80.0;\n            let points_n_n_plus_1 = point_n.zip(point_n_plus_1);\n            for (point_n, point_n_plus_1) in points_n_n_plus_1 {\n                // segmenting points on the line into more points\n                let (start_x, final_x) = (point_n.tangential.x(), point_n_plus_1.tangential.x());\n                let (start_y, final_y) = (point_n.tangential.y(), point_n_plus_1.tangential.y());\n                let (start_z, final_z) = (point_n.tangential.z(), point_n_plus_1.tangential.z());\n\n                let (x_step, y_step, z_step) = (\n                    (final_x - start_x) / steps,\n                    (final_y - start_y) / steps,\n                    (final_z - start_z) / steps,\n                );\n\n                let (mut x, mut y, mut z) = (start_x, start_y, start_z);\n\n                for _ in 0..steps as u32 {\n                    let temp_point = TangentialPoint::new(x, y, z);\n                    let temp_distance_to_robot = temp_point.distance(robot_loc);\n\n                    if temp_distance_to_robot \u003c= ROBOT_RADIUS\n                        \u0026\u0026 temp_distance_to_robot \u003c closest_point.distance(robot_loc)\n                    {\n                        closest_point = temp_point;\n                        closest_edge_index = Some(edge_index);\n                    }\n\n                    x += x_step;\n                    y += y_step;\n                    z += z_step;\n                }\n            }\n        }\n\n        match closest_edge_index {\n            None =\u003e Err(Error::PathPlanningNotOnMap),\n            Some(closest_edge_index) =\u003e self.connection_matrix_index_from(closest_edge_index),\n        }\n    }\n\n    fn connection_matrix_index_from(\u0026self, edge_index: EdgeIndex) -\u003e Result\u003cMatrixIndex, Error\u003e {\n        for row in 0..self.connection_matrix.nrows() {\n            for col in 0..self.connection_matrix.ncols() {\n                if Some(edge_index) == self.connection_matrix[(row, col)] {\n                    return Ok(MatrixIndex { ith: row, jth: col });\n                }\n            }\n        }\n\n        Err(Error::PathPlanningEdgeIndexNotInConnectionMatrix)\n    }\n\n    fn shortest_path(\n        \u0026mut self,\n        start_vertex_index: VertexIndex,\n        end_vertex_index: VertexIndex,\n    ) -\u003e Result\u003cPath, Error\u003e {\n        // Initializing the the graph so all tentative distances are 0\n        // and not parent vertices are set.\n        for vertex in self.vertices.iter_mut() {\n            vertex.tentative_distance = f64::MAX;\n            vertex.visited = false;\n            vertex.parent_vertex_index = None;\n        }\n\n        // Setting the tentative distance of the start vertex to 0\n        self.vertices[start_vertex_index].tentative_distance = 0.0;\n\n        let mut vertex_index = start_vertex_index; // Keeps track of currently visiting vertex\n        let mut nodes_not_visited = self.vertices.len();\n\n        while nodes_not_visited != 0 \u0026\u0026 vertex_index != end_vertex_index {\n            let mut vertex = \u0026mut self.vertices[vertex_index] as *mut Vertex;\n            let connecting_edges = self.connection_matrix.row(vertex_index);\n            let adj_vertices = connecting_edges\n                .iter()\n                .enumerate()\n                .filter(|(_, edge_index)| edge_index.is_some())\n                .map(|(vertex_index, edge_index)| (vertex_index, edge_index.unwrap()));\n\n            for (adj_vertex_index, edge_index) in adj_vertices {\n                let adj_vertex = \u0026mut self.vertices[adj_vertex_index] as *mut Vertex;\n                let connecting_edge = \u0026self.edges[edge_index];\n\n                // Using the unsafe keywords since more than one mutable reference is needed.\n                // One to the currently visiting vertex and the other to the adjacent vertex.\n                unsafe {\n                    if !(*adj_vertex).visited {\n                        let temp_distance = (*vertex).tentative_distance + connecting_edge.distance;\n\n                        if temp_distance \u003c (*adj_vertex).tentative_distance {\n                            (*adj_vertex).tentative_distance = temp_distance;\n                            (*adj_vertex).parent_vertex_index = Some(vertex_index);\n                        }\n                    }\n                }\n            }\n            unsafe {\n                (*vertex).visited = true;\n            }\n            nodes_not_visited -= 1;\n\n            // Selecting the next node to visit\n            let mut min_dist = f64::MAX;\n            for (index, vertex) in self.vertices.iter().enumerate() {\n                if vertex.tentative_distance \u003c min_dist \u0026\u0026 !vertex.visited {\n                    min_dist = vertex.tentative_distance;\n                    vertex_index = index;\n                }\n            }\n        }\n\n        // After completing the while loop, we have either found the shortest path,\n        // or one does not exist. If one exists, then a stack of matrix indices will be outputted\n        // otherwise, an error message will be returned, indicating the path does not exist.\n        let dest_vertex = \u0026self.vertices[end_vertex_index];\n        if dest_vertex.tentative_distance == f64::MAX {\n            return Err(Error::PathPlanningPathDoesNotExist);\n        }\n\n        // Pre allocating memory. Chosen path will never exceed the number of edges in the graph.\n        let mut connection_matrix_indices = Vec::with_capacity(self.edges.len());\n\n        let mut path_vertex_index = end_vertex_index;\n        while path_vertex_index != start_vertex_index {\n            let parent_vertex_index = self.vertices[path_vertex_index]\n                .parent_vertex_index\n                .unwrap();\n            let matrix_index = MatrixIndex {\n                ith: parent_vertex_index,\n                jth: path_vertex_index,\n            };\n\n            connection_matrix_indices.push(matrix_index);\n\n            path_vertex_index = parent_vertex_index;\n        }\n\n        // Reversing the order of the connection matrix index so instructions are given from the\n        // start to the end and not end to start.\n        connection_matrix_indices = connection_matrix_indices.into_iter().rev().collect();\n\n        Ok(Path {\n            indices: connection_matrix_indices,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":8,"address":[4755424],"length":1,"stats":{"Line":0},"fn_name":"plan_path"},{"line":21,"address":[4755456],"length":1,"stats":{"Line":1},"fn_name":"edges"},{"line":22,"address":[4755478,4755536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4265006,4264992],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4755600],"length":1,"stats":{"Line":0},"fn_name":"edges"},{"line":31,"address":[4755683,4755617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4265054,4265040],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":39,"address":[4755800,4755744],"length":1,"stats":{"Line":1},"fn_name":"vertices"},{"line":41,"address":[4755767,4756272,4755820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4755936,4755867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4265088,4265102],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4756254,4755966,4756153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4756224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4756247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4756146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4756336,4756392],"length":1,"stats":{"Line":0},"fn_name":"vertices"},{"line":63,"address":[4756867,4756359,4756412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4756531,4756459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4265152,4265166],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":70,"address":[4756748,4756849,4756561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4756819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4756842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4756741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4273280],"length":1,"stats":{"Line":1},"fn_name":"closest_edge_to"},{"line":86,"address":[4273306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4273446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4273486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4273693,4273498,4274162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[4273759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4273870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4273937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4273958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4273967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[4274012,4274995,4274167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[4274233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4274375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4274509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4274693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4274655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4274676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4274685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[4274774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4274856,4275000,4275433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[4275023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4275063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4275169,4275196,4275113],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[4275141,4275192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[4275205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4275309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4275367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4275391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[4275415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[4275497,4275480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4273669,4275490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4275438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4275520],"length":1,"stats":{"Line":1},"fn_name":"connection_matrix_index_from"},{"line":137,"address":[4275546,4275733,4275930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[4275772,4276107,4275935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[4275981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[4276117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4275721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[4276303,4276192],"length":1,"stats":{"Line":1},"fn_name":"shortest_path"},{"line":155,"address":[4276226,4276601,4276514,4276334],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[4276556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[4276561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4276565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[4276485,4276606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[4276630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4276646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4277670,4276662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[4276789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4276834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[4276865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4265216,4265230],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":174,"address":[4265306,4265280],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":176,"address":[4277438,4277123,4276949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[4277204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4277256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4277302,4277436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4277320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[4277349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[4277379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[4277384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4277082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[4277086,4278555,4277456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[4277464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4277481,4277858,4277675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[4277744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4277831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[4277850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4277879,4276742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4277887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4277939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4277910,4277962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4277996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[4278012,4278258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4278109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4278215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[4278250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4278279,4278043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[4278421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[4278365],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":90,"coverable":107},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","path_planning","tests.rs"],"content":"use crate::graph;\nuse crate::graph::conversions::IntoTangential;\nuse crate::graph::{Edges, MatrixIndex, Vertex, Vertices};\nuse crate::path_planning::*;\nuse crate::Error;\n\n#[test]\nfn robot_on_graph_false_case() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    let middle_of_watson_lake = graph::GPSPointDeg {\n        lat: 34.351398,\n        long: -112.250598,\n        height: 1565.0,\n    }\n    .into_tangential();\n\n    let robot_on_path = graph.closest_edge_to(\u0026middle_of_watson_lake);\n\n    assert_eq!(robot_on_path, Err(Error::PathPlanningNotOnMap));\n}\n\n#[test]\nfn robot_on_graph_true_case() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n    let king_front_entrance_edge_index = graph\n        .edges\n        .iter()\n        .enumerate()\n        .filter(|(_, edge)| edge.name.contains(\"Line 26\"))\n        .map(|(edge_index, _)| edge_index)\n        .next()\n        .unwrap();\n    let expected_matrix_index = graph.connection_matrix_index_from(king_front_entrance_edge_index);\n\n    let king_front_entrance = graph::GPSPointDeg {\n        lat: 34.6147979,\n        long: -112.4509615,\n        height: 1582.3,\n    }\n    .into_tangential();\n\n    let matrix_index = graph.closest_edge_to(\u0026king_front_entrance);\n\n    assert_eq!(expected_matrix_index, matrix_index);\n}\n\n#[test]\nfn robot_not_on_graph_within_radius() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    // Enter lat long in google maps if you wish to verify location of point with our school map\n    let close_point = GPSPointDeg {\n        lat: 34.6148261,\n        long: -112.4508876,\n        height: 1582.0,\n    }\n    .into_tangential();\n\n    let expected_edge = graph.closest_edge_to(\u0026close_point).unwrap().edge(\u0026graph); // Taking the matrix index and returning a reference to the edge\n\n    assert!(expected_edge.name.contains(\"Line 28\"));\n}\n\n#[test]\nfn connection_matrix_index_from_edge_index_single_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let edge_index = 0;\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let matrix_index = graph.connection_matrix_index_from(edge_index);\n\n    assert_eq!(\n        matrix_index,\n        Ok(MatrixIndex {\n            ith: vertex_index_0,\n            jth: vertex_index_1\n        })\n    );\n}\n\n#[test]\nfn connection_matrix_index_from_edge_not_in_connection_matrix() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let faulty_edge_index = 1;\n\n    let matrix_index = graph.connection_matrix_index_from(faulty_edge_index);\n\n    assert_eq!(\n        matrix_index,\n        Err(Error::PathPlanningEdgeIndexNotInConnectionMatrix)\n    );\n}\n\n#[test]\nfn shortest_path_triangle() {\n    // Preview this map to see how the names correspond to each vertex and edge\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Triangle.gpx\");\n\n    // Indices of the vertices get set in the order in which they are read from the gpx file.\n    let start = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 2\"))\n        .unwrap();\n    let end = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 3\"))\n        .unwrap();\n\n    let shortest_path = graph.shortest_path(start, end).unwrap();\n\n    let edges_chosen = shortest_path.edges(\u0026graph);\n    let mut edges_chosen = edges_chosen.iter();\n\n    let vertices_chosen = shortest_path.vertices(\u0026graph);\n    let mut vertices_chosen = vertices_chosen.iter();\n\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 5\"));\n    assert_eq!(edges_chosen.next(), None);\n\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 2\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 3\"));\n    assert_eq!(vertices_chosen.next(), None);\n}\n\n#[test]\nfn shortest_path_school_map() {\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    let king_front_entrance = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"King Engineering (Front Entrance)\"))\n        .unwrap();\n\n    let library = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Library\"))\n        .unwrap();\n\n    let path = graph.shortest_path(king_front_entrance, library).unwrap();\n\n    let edges_chosen = path.edges(\u0026graph);\n    let mut edges_chosen = edges_chosen.iter();\n\n    let vertices_chosen = path.vertices(\u0026graph);\n    let mut vertices_chosen = vertices_chosen.iter();\n\n    // See map preview or write path to GeoJson to visually confirm assertions\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 26\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 32\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 30\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 35\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 36\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 37\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 38\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 39\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 40\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 41\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 42\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 16\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 17\"));\n    assert_eq!(edges_chosen.next(), None);\n\n    assert!(vertices_chosen\n        .next()\n        .unwrap()\n        .name\n        .contains(\"King Engineering (Front Entrance)\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 25\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 17\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 18\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 28\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 29\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 30\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 31\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 32\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 33\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 34\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 12\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 5\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Library\"));\n    assert_eq!(vertices_chosen.next(), None);\n}\n\n#[test]\nfn shortest_path_no_path() {\n    // Use map preview for visual verification of points chosen for test\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Dijkstra.gpx\");\n    let start_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 12\"))\n        .unwrap();\n    let end_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 16\"))\n        .unwrap();\n\n    let shortest_path = graph.shortest_path(start_vertex_index, end_vertex_index);\n\n    assert_eq!(shortest_path, Err(Error::PathPlanningPathDoesNotExist));\n}\n\n#[test]\nfn shortest_path_dijkstra_graph() {\n    // Use map preview for visual verification of points chosen for test\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Dijkstra.gpx\");\n    let start_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 12\"))\n        .unwrap();\n    let end_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 5\"))\n        .unwrap();\n\n    let shortest_path = graph\n        .shortest_path(start_vertex_index, end_vertex_index)\n        .unwrap();\n\n    let vertices_chosen = shortest_path.vertices(\u0026graph);\n    let mut vertices_chosen = vertices_chosen.iter();\n\n    let edges_chosen = shortest_path.edges(\u0026graph);\n    let mut edges_chosen = edges_chosen.iter();\n\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 12\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 1\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 17\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 16\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 4\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 5\"));\n    assert_eq!(vertices_chosen.next(), None);\n\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 13\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 18\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 19\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 20\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 14\"));\n}\n\n#[test]\nfn vertices_for_path_single_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let path = Path {\n        indices: vec![MatrixIndex {\n            ith: vertex_index_0,\n            jth: vertex_index_1,\n        }],\n    };\n\n    assert_eq!(\n        path.vertices(\u0026graph),\n        vec![\u0026graph.vertices[0], \u0026graph.vertices[1]]\n    )\n}\n\n#[test]\nfn vertices_for_path_triangle() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Triangle.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n    let vertex_index_2 = 2;\n\n    let path = Path {\n        indices: vec![\n            MatrixIndex {\n                ith: vertex_index_0,\n                jth: vertex_index_1,\n            },\n            MatrixIndex {\n                ith: vertex_index_1,\n                jth: vertex_index_2,\n            },\n        ],\n    };\n\n    let expected_vertices: Vec\u003c\u0026Vertex\u003e = graph.vertices.iter().collect();\n\n    assert_eq!(path.vertices(\u0026graph), expected_vertices)\n}\n","traces":[{"line":8,"address":[4565648,4565682],"length":1,"stats":{"Line":3},"fn_name":"robot_on_graph_false_case"},{"line":9,"address":[4565662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4565740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4565874,4565759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4566208,4566245],"length":1,"stats":{"Line":3},"fn_name":"robot_on_graph_true_case"},{"line":25,"address":[4566222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4566363,4566260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4646334,4646320],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":31,"address":[4646432,4646450],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":34,"address":[4566503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4566559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4566685,4566574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4567024,4567058],"length":1,"stats":{"Line":3},"fn_name":"robot_not_on_graph_within_radius"},{"line":50,"address":[4567038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4567135,4567116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4567231,4567306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4567410,4567376],"length":1,"stats":{"Line":3},"fn_name":"connection_matrix_index_from_edge_index_single_edge"},{"line":67,"address":[4567390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4567425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4567437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4567449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4567478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4567680,4567557,4567659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[4567485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4568050,4568016],"length":1,"stats":{"Line":3},"fn_name":"connection_matrix_index_from_edge_not_in_connection_matrix"},{"line":85,"address":[4568030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4568065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4568095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4568102,4568211,4568232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4568613,4568576],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_triangle"},{"line":99,"address":[4568590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4568721,4568636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[4646592,4646606],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":107,"address":[4568842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[4646686,4646672],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":113,"address":[4569049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4569113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4569185,4569231,4569128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[4569279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4569294,4569382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4569571,4569414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4569758,4569556,4569612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[4570118,4569740,4570260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[4570408,4570245,4570293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4570446,4570572,4570396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[4571061,4571024],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_school_map"},{"line":131,"address":[4571038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4571084,4571169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[4646784,4646798],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":139,"address":[4571290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4646864,4646878],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":145,"address":[4571497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4571561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[4571679,4571633,4571576],"length":1,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[4571727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[4571742,4571830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[4572019,4571862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[4572004,4572194,4572052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[4572227,4572179,4572369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[4572544,4572354,4572402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4572529,4572719,4572577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4572752,4572894,4572704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[4572879,4573069,4572927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[4573054,4573102,4573244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[4573419,4573229,4573277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[4573452,4573594,4573404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[4573769,4573579,4573627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[4573944,4573754,4573802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[4573929,4574119,4573977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4574104,4574160,4574306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[4574808,4574666,4574288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[4574793,4574983,4574841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[4574968,4575016,4575158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[4575191,4575333,4575143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[4575318,4575366,4575508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[4575493,4575541,4575683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[4575668,4575716,4575858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[4576033,4575891,4575843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4576066,4576208,4576018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4576383,4576241,4576193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[4576368,4576416,4576558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4576543,4576733,4576591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4576718,4576766,4576908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4576893,4576941,4577056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4577044,4577220,4577094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4577664,4577701],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_no_path"},{"line":193,"address":[4577678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4577724,4577809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4646976,4646990],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":199,"address":[4577930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4647056,4647070],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":205,"address":[4578113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[4578123,4578261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4578640,4578677],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_dijkstra_graph"},{"line":213,"address":[4578654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[4578700,4578785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[4647182,4647168],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":219,"address":[4578906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[4647248,4647262],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":225,"address":[4579113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4579177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4579249,4579295,4579192],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[4579343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4579446,4579358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4579478,4579635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4579620,4579810,4579668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[4579985,4579843,4579795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[4580018,4580160,4579970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[4580145,4580193,4580335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[4580510,4580320,4580368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[4580495,4580697,4580551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4581199,4580679,4581057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4581371,4581184,4581232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[4581359,4581404,4581516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[4581549,4581504,4581661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[4581649,4581801,4581694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[4581968,4582002],"length":1,"stats":{"Line":3},"fn_name":"vertices_for_path_single_edge"},{"line":252,"address":[4581982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[4582017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[4582029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[4582051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[4582561,4582405,4582537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[4582194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[4582913,4582211,4582270,4582344],"length":1,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[4583138,4583104],"length":1,"stats":{"Line":3},"fn_name":"vertices_for_path_triangle"},{"line":271,"address":[4583118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4583153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4583165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4583177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4583199,4583252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[4583374,4583451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[4583599,4583479,4583685],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":132,"coverable":132},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","states.rs"],"content":"#[derive(PartialEq, Debug)]\npub enum States {\n    Wait,\n    PlanPath,\n    Traverse,\n    Shutdown,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","traversal","mod.rs"],"content":"// The following is a link to our proof of concept\n//\n// https://www.geogebra.org/classic/jwwnnxy6\n\nuse crate::graph::TangentialPoint;\nuse cfg_if::cfg_if;\n\n// Determines when we increment to our next point. Once we have traversed the\n// percentage of 1 - OFFSET_FACTOR, we increment the point we are attempting to\n// traverse to.\ncfg_if! {\n    if #[cfg(test)] { // So unit tests never break\n        const OFFSET_FACTOR: f64 = 0.09;\n    }\n    else { // Here we can tweek this factor when experimenting with the robot.\n        const OFFSET_FACTOR: f64 = 0.09;\n    }\n}\n\npub struct ProximityLine {\n    m: f64,\n    b: f64,\n}\n\nimpl ProximityLine {\n    // Create the proximity line given the robot location and the next point we\n    // wish to traverse to. Be sure to consult the proof of concept to get a\n    // visual understanding for what this function is doing.\n    //\n    // https://www.geogebra.org/classic/jwwnnxy6\n    pub fn new(robot_loc: \u0026TangentialPoint, next_point: \u0026TangentialPoint) -\u003e Self {\n        // The vector that goes from our robot to the next point to traverse.\n        let ideal_traversal_v = next_point - robot_loc;\n\n        // The amount we move back from next point to place our proximity line.\n        let proximity_offset = ideal_traversal_v * OFFSET_FACTOR;\n\n        // A point that will lie on the proximity line\n        let proximity_point = next_point - \u0026proximity_offset;\n\n        // The slope of the proximity line. Garunteed to be perpendicular to the\n        // line that goes from our robot to the next desired point\n        let m = (-1.0) * ideal_traversal_v.x() / ideal_traversal_v.y();\n\n        // The y intercept of our line\n        let b = proximity_point.y() - m * proximity_point.x();\n\n        ProximityLine { m, b }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":31,"address":[4757184],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":33,"address":[4757207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4757243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4757300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4757323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4757404],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","traversal","tests.rs"],"content":"use super::*;\n\n// TO confirm, use the geogebra tool and put the robot_loc and next point in the\n// locations corresponding to the test.\n//\n// https://www.geogebra.org/classic/jwwnnxy6\n\n#[test]\nfn new_proximity_line() {\n    let prev_point = TangentialPoint::new(0.0, 1.2, 0.0);\n    let next_point = TangentialPoint::new(2.0, 1.0, 0.0);\n\n    let proximity_line = ProximityLine::new(\u0026prev_point, \u0026next_point);\n\n    assert!(\n        proximity_line.m \u003e 9.9\n            \u0026\u0026 proximity_line.m \u003c 10.1\n            \u0026\u0026 proximity_line.b \u003e -17.19\n            \u0026\u0026 proximity_line.b \u003c -17.17\n    );\n}\n\n#[test]\nfn horizontal_proximity_line() {\n    let prev_point = TangentialPoint::new(0.0, 1.0, 0.0);\n    let next_point = TangentialPoint::new(0.0, 3.0, 0.0);\n\n    let proximity_line = ProximityLine::new(\u0026prev_point, \u0026next_point);\n\n    assert_eq!(proximity_line.m, 0.0);\n}\n\n#[test]\nfn vertical_proximity_line() {\n    use std::f64;\n\n    let prev_point = TangentialPoint::new(0.0, 1.0, 0.0);\n    let next_point = TangentialPoint::new(2.0, 1.0, 0.0);\n\n    let proximity_line = ProximityLine::new(\u0026prev_point, \u0026next_point);\n\n    assert_eq!(proximity_line.m, f64::NEG_INFINITY);\n}\n","traces":[{"line":9,"address":[4211376],"length":1,"stats":{"Line":3},"fn_name":"new_proximity_line"},{"line":10,"address":[4211388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4211429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4211442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4211539,4211676,4211646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4211495,4211535,4211628,4211551,4211583],"length":1,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[4211624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4211579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4211531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4211680],"length":1,"stats":{"Line":3},"fn_name":"horizontal_proximity_line"},{"line":25,"address":[4211695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4211728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4211763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4211786,4211900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4212192],"length":1,"stats":{"Line":3},"fn_name":"vertical_proximity_line"},{"line":37,"address":[4212207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4212248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4212271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4212408,4212294],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","ui.rs"],"content":"use cfg_if::cfg_if;\nuse lazy_static::*;\n\nuse std::sync::Mutex;\n\npub const PATH_TO_UI_PIPE: \u0026str = \"to_ui\";\npub const PATH_FROM_UI_PIPE: \u0026str = \"from_ui\";\n\ncfg_if! {\n    if #[cfg(test)] {\n        use mockall::*;\n        use std::io;\n        use std::io::Write;\n\n        mock! {\n            pub File {}\n            trait Write {\n                fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e;\n                fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e;\n            }\n        }\n\n        lazy_static! {\n            // Opening the pipe with write permissions will block until the reader opens the file as well.\n            pub static ref TO_UI: Mutex\u003cMockFile\u003e = Mutex::new(MockFile::new());\n        }\n\n        lazy_static! {\n            pub static ref FROM_UI: Mutex\u003cMockFile\u003e = Mutex::new(MockFile::new());\n        }\n    }\n    else {\n        use std::fs::{OpenOptions, File};\n\n        lazy_static! {\n            // Opening the pipe with write permissions will block until the reader opens the file as well.\n            pub static ref TO_UI: Mutex\u003cFile\u003e = Mutex::new(OpenOptions::new()\n                .append(true)\n                .create_new(false)\n                .open(PATH_TO_UI_PIPE)\n                .unwrap() // Not sure how we want to handle an error here.\n            );\n        }\n\n        lazy_static! {\n            pub static ref FROM_UI: Mutex\u003cFile\u003e = Mutex::new(OpenOptions::new()\n                .read(true)\n                .open(PATH_FROM_UI_PIPE)\n                .unwrap() // Not sure how we want to handle an error here.\n            );\n        }\n    }\n}\n","traces":[{"line":15,"address":[4234896,4236426,4237435,4237324,4237216,4234975,4233901,4236051,4234914,4235570,4233888,4236284,4236720,4237230,4237182,4234550,4236947,4237168,4236499,4236567,4234864,4235978,4236732,4236119,4235824,4236272,4237248,4234846,4234944,4233920,4234873,4233935,4237015,4234055,4235836,4234832,4237408,4236874],"length":1,"stats":{"Line":95},"fn_name":"{{closure}}"},{"line":18,"address":[4237233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4440823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4443159],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":4}]};
        var previousData = {"files":[{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","constants.rs"],"content":"// Radius used to check if the robot is on the graph (m)\npub const ROBOT_RADIUS: f64 = 1.5;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","error","mod.rs"],"content":"use crate::states::States;\n\n#[derive(PartialEq, Debug)]\npub enum Error {\n    WaitingSubSystem,\n    PathPlanningPathDoesNotExist,\n    PathPlanningNotOnMap,\n    PathPlanningEdgeIndexNotInConnectionMatrix,\n}\n\nimpl Error {\n    pub fn handle(\u0026self) -\u003e Result\u003cStates, Error\u003e {\n        unimplemented!();\n    }\n}\n","traces":[{"line":12,"address":[4283312],"length":1,"stats":{"Line":0},"fn_name":"handle"}],"covered":0,"coverable":1},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","graph","conversions.rs"],"content":"use super::{Edges, GPSPointDeg, GPSPointRad, Graph, TangentialPoint, Vertices};\nuse geojson::{feature::Id, Feature, FeatureCollection, Geometry, Value};\nuse nalgebra::{Matrix3, Vector3};\n\n// Distance from the earth relative to the equator (m)\nconst RO: f64 = 6_378_137.0;\n\n// Ecentricity of the earth (unitless?)\nconst E: f64 = 0.0818;\n\n// Front entrance of king\nconst ORIGIN: GPSPointDeg = GPSPointDeg {\n    lat: 34.614_797_9,\n    long: -112.450_961_5,\n    height: 1582.3,\n};\n\npub fn geo_json_string\u003cT\u003e(elements: T, graph: \u0026Graph) -\u003e String\nwhere\n    T: Edges + Vertices,\n{\n    // Allocating Memory\n    let number_of_vertices_and_edges = elements.edges(graph).len() + elements.vertices(graph).len();\n    let mut features = Vec::with_capacity(number_of_vertices_and_edges);\n\n    for edge in elements.edges(graph).iter() {\n        let edge_points = edge\n            .points\n            .iter()\n            .map(|point| vec![point.gps.long, point.gps.lat])\n            .collect();\n\n        let geometry = Geometry::new(Value::LineString(edge_points));\n\n        let feature = Feature {\n            bbox: None,\n            geometry: Some(geometry),\n            id: Some(Id::String(edge.name.clone())),\n            properties: None,\n            foreign_members: None,\n        };\n\n        features.push(feature);\n    }\n\n    for vertex in elements.vertices(graph).iter() {\n        let vertex_point = vec![vertex.point.gps.long, vertex.point.gps.lat];\n\n        let geometry = Geometry::new(Value::Point(vertex_point));\n\n        let feature = Feature {\n            bbox: None,\n            geometry: Some(geometry),\n            id: Some(Id::String(vertex.name.clone())),\n            properties: None,\n            foreign_members: None,\n        };\n\n        features.push(feature);\n    }\n\n    let feature_collection = FeatureCollection {\n        bbox: None,\n        features,\n        foreign_members: None,\n    };\n\n    feature_collection.to_string()\n}\n\npub trait IntoTangential {\n    type Output;\n\n    fn into_tangential(\u0026self) -\u003e Self::Output;\n}\n\nimpl IntoTangential for GPSPointDeg {\n    type Output = TangentialPoint;\n\n    fn into_tangential(\u0026self) -\u003e TangentialPoint {\n        let origin = ORIGIN.to_rad();\n\n        // vector from center of the earth to an arbitrary point on the map\n        let r_ek_e = self.to_rad().to_xyz();\n\n        // vector from the center of the earth to the origin of our tangential frame\n        let r_eb_e = origin.to_xyz();\n\n        // Vector that goes from origin to an arbitrary point of the map.\n        // Still being expressed in terms of a rectangular frame with its origin at the center of\n        // the earth.\n        let r_kb_e = r_eb_e - r_ek_e;\n\n        // The transformation matrix that converts the basis or our coordinate system\n        let c_e_k = Matrix3::new(\n            -(self.to_rad().long.cos() * self.to_rad().lat.sin()),\n            -origin.long.sin(),\n            -(origin.lat.cos() * origin.long.cos()),\n            -(origin.lat.sin() * origin.long.sin()),\n            origin.long.cos(),\n            -(origin.lat.cos() * origin.long.sin()),\n            origin.lat.cos(),\n            0.0,\n            -origin.lat.sin(),\n        )\n        .try_inverse()\n        .unwrap();\n\n        let result = c_e_k * r_kb_e;\n\n        TangentialPoint { vector: result }\n    }\n}\n\nimpl GPSPointDeg {\n    /// Converts the GPS from degrees to radians\n    fn to_rad(\u0026self) -\u003e GPSPointRad {\n        GPSPointRad {\n            lat: self.lat.to_radians(),\n            long: self.long.to_radians(),\n            height: self.height,\n        }\n    }\n}\n\nimpl GPSPointRad {\n    /// Converts spherical cords to rectangular\n    fn to_xyz(\u0026self) -\u003e Vector3\u003cf64\u003e {\n        // The distance from the center of the earth relative to where you are (m)\n        let re = RO / (1.0 - self.lat.sin().powi(2) * E.powi(2)).sqrt();\n\n        Vector3::new(\n            (re + self.height) * self.lat.cos() * self.long.cos(),\n            (re + self.height) * self.lat.cos() * self.long.sin(),\n            ((re + re * E.powi(2)) + self.height) * self.lat.sin(),\n        )\n    }\n}\n","traces":[{"line":18,"address":[4641040,4641124],"length":1,"stats":{"Line":1},"fn_name":"geo_json_string\u003c\u0026rust_code::graph::Graph\u003e"},{"line":23,"address":[4644019,4641066,4641188,4641147],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4641335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4642571,4641394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4641676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4644193,4644176],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003c\u0026rust_code::graph::Graph\u003e"},{"line":33,"address":[4641808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4641923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4642123,4642180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4642532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4642600,4643670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4642855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4642910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4643025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4643222,4643279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4643631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4643851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4265536],"length":1,"stats":{"Line":1},"fn_name":"into_tangential"},{"line":81,"address":[4265554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4265604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4265646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4265667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4265792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4265925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[4265992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4266077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4266162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4266188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4266267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4266293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4266477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4266704],"length":1,"stats":{"Line":1},"fn_name":"to_rad"},{"line":119,"address":[4266716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4266751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4266772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4266832],"length":1,"stats":{"Line":1},"fn_name":"to_xyz"},{"line":130,"address":[4266850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4267025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[4267150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4267258],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":40},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","graph","mod.rs"],"content":"use std::f64;\nuse std::fs::File;\nuse std::io::BufReader;\nuse std::ops::{Mul, Sub};\n\nuse conversions::IntoTangential;\nuse gpx;\nuse nalgebra::{DMatrix, Vector3};\n\npub mod conversions;\n\npub type EdgeIndex = usize;\npub type VertexIndex = usize;\n\n// Clone trait only for unit testing\n#[derive(Debug, Clone, PartialEq)]\npub struct Point {\n    pub gps: GPSPointDeg,\n    pub tangential: TangentialPoint,\n}\n\n// Clone Trait only for unit testing\n#[derive(Debug, PartialEq, Clone, Copy)]\npub struct TangentialPoint {\n    vector: Vector3\u003cf64\u003e,\n}\n\nimpl Sub for \u0026TangentialPoint {\n    type Output = TangentialPoint;\n\n    fn sub(self, other: Self) -\u003e TangentialPoint {\n        TangentialPoint {\n            vector: self.vector - other.vector,\n        }\n    }\n}\n\nimpl Mul\u003cf64\u003e for TangentialPoint {\n    type Output = Self;\n\n    fn mul(self, rhs: f64) -\u003e Self::Output {\n        TangentialPoint {\n            vector: self.vector * rhs,\n        }\n    }\n}\n\nimpl TangentialPoint {\n    pub fn new(x: f64, y: f64, z: f64) -\u003e Self {\n        TangentialPoint {\n            vector: Vector3::new(x, y, z),\n        }\n    }\n    pub fn x(\u0026self) -\u003e f64 {\n        self.vector[0]\n    }\n    pub fn y(\u0026self) -\u003e f64 {\n        self.vector[1]\n    }\n    pub fn z(\u0026self) -\u003e f64 {\n        self.vector[2]\n    }\n    pub fn distance(\u0026self, other: \u0026Self) -\u003e f64 {\n        let point = other - self;\n\n        (point.x().powi(2) + point.y().powi(2) + point.z().powi(2)).sqrt()\n    }\n}\n\n// Clone trait only for unit testing\n#[derive(Debug, Clone)]\npub struct GPSPointDeg {\n    pub lat: f64,\n    pub long: f64,\n    pub height: f64,\n}\n\nimpl PartialEq for GPSPointDeg {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.lat == other.lat \u0026\u0026 self.long == other.long\n    }\n}\n\npub(self) struct GPSPointRad {\n    pub(self) lat: f64,\n    pub(self) long: f64,\n    pub(self) height: f64,\n}\n\n#[derive(Debug, PartialEq)]\npub struct Edge {\n    // For debugging, finding out what line we are looking at on the map\n    pub name: String,\n\n    // T, in this case, can be a point relative to our tangential frame, or the gps frame\n    pub points: Vec\u003cPoint\u003e,\n\n    pub distance: f64,\n}\n\nimpl Edge {\n    fn new(name: String, points: Vec\u003cPoint\u003e) -\u003e Self {\n        // Determining the distance of the edge for construction\n        let mut distance = 0.0;\n\n        let points_n = points.iter().map(|point| \u0026point.tangential);\n        let mut points_n_plus_1 = points.iter().map(|point| \u0026point.tangential);\n        points_n_plus_1.next();\n\n        // Combines the iterator of point_n and point_n_plus_one iterator into a single iterator so if may be consumed\n        // in the for loop.\n        let points_n_n_plus_1 = points_n.zip(points_n_plus_1);\n\n        for (point_n, points_n_plus_1) in points_n_n_plus_1 {\n            distance += point_n.distance(\u0026points_n_plus_1);\n        }\n\n        Edge {\n            name,\n            points,\n            distance,\n        }\n    }\n}\n\npub trait Edges {\n    fn edges\u003c'edge, 'graph\u003e(\u0026'edge self, graph: \u0026'graph Graph) -\u003e Vec\u003c\u0026'graph Edge\u003e;\n}\n\n#[derive(Debug, PartialEq)]\n// A is a lifetime\npub struct Vertex {\n    // Will be used to display key locations to UI\n    pub name: String,\n\n    // Will be used to identify adjacent nodes and edges. T will be either a GPSPoint or a point\n    // in our tangential frame.\n    pub(self) point: Point,\n\n    // Key data to determine the shortest path using Dijkstra's Algorithm\n    pub parent_vertex_index: Option\u003cVertexIndex\u003e,\n    pub tentative_distance: f64,\n    pub visited: bool,\n}\n\nimpl Vertex {\n    fn new(name: String, gps: GPSPointDeg) -\u003e Vertex {\n        let tangential = gps.into_tangential();\n\n        let point = Point { gps, tangential };\n\n        Vertex {\n            name,\n            point,\n            parent_vertex_index: None,\n            tentative_distance: f64::MAX,\n            visited: false,\n        }\n    }\n}\n\n// Element at a matrix_index[i][j] indicates an Edge Index\n#[derive(Debug, PartialEq)]\npub struct MatrixIndex {\n    pub ith: VertexIndex,\n    pub jth: VertexIndex,\n}\n\nimpl MatrixIndex {\n    pub fn edge\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e \u0026'b Edge {\n        let edge_index = graph.connection_matrix[(self.ith, self.jth)].unwrap();\n        \u0026graph.edges[edge_index]\n    }\n\n    pub fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e (\u0026'b Vertex, \u0026'b Vertex) {\n        let (index_1, index_2) = (self.ith, self.jth);\n\n        (\u0026graph.vertices[index_1], \u0026graph.vertices[index_2])\n    }\n}\n\npub trait Vertices {\n    fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Vertex\u003e;\n}\n\npub struct Graph {\n    pub vertices: Vec\u003cVertex\u003e,\n    pub edges: Vec\u003cEdge\u003e,\n    pub connection_matrix: DMatrix\u003cOption\u003cEdgeIndex\u003e\u003e,\n}\n\nimpl Vertices for \u0026Graph {\n    fn vertices\u003c'vertex, 'graph\u003e(\u0026'vertex self, graph: \u0026'graph Graph) -\u003e Vec\u003c\u0026'graph Vertex\u003e {\n        graph.vertices.iter().collect()\n    }\n}\n\nimpl Edges for \u0026Graph {\n    fn edges\u003c'edge, 'graph\u003e(\u0026'edge self, graph: \u0026'graph Graph) -\u003e Vec\u003c\u0026'graph Edge\u003e {\n        graph.edges.iter().collect()\n    }\n}\n\npub(self) fn connect_vertices_with_edges(edges: Vec\u003cEdge\u003e, vertices: Vec\u003cVertex\u003e) -\u003e Graph {\n    let vertices_len = vertices.len();\n\n    let mut connection_matrix = DMatrix::from_vec(\n        vertices_len,                            // number of rows\n        vertices_len,                            // number of columns\n        vec![None; vertices_len * vertices_len], // initializing the array to None\n    );\n\n    // Iterating though all edges and vertices. When the first and last point of an edge match two vertices, then the\n    // connection matrix at v_m v_n and v_n v_m gets populated with the index to the edges vector.\n    for (edge_index, edge) in edges.iter().enumerate() {\n        let start_of_edge = edge.points.first().unwrap();\n        let end_of_edge = edge.points.last().unwrap();\n        let mut start_vertex_index = None;\n        let mut end_vertex_index = None;\n\n        for (vertex_index, vertex) in vertices.iter().enumerate() {\n            if vertex.point.gps == start_of_edge.gps {\n                start_vertex_index = Some(vertex_index);\n            } else if vertex.point.gps == end_of_edge.gps {\n                end_vertex_index = Some(vertex_index);\n            }\n        }\n\n        match (start_vertex_index, end_vertex_index) {\n            // If the start and end vertices have been assigned then we know the edge that connects those two vertices.\n            // The connection matrix should be updated to reflex that we know the edge and is associated vertices.\n            (Some(start_vertex_index), Some(end_vertex_index)) =\u003e {\n                connection_matrix[(start_vertex_index, end_vertex_index)] = Some(edge_index);\n                connection_matrix[(end_vertex_index, start_vertex_index)] = Some(edge_index);\n            }\n\n            // If either one of them didn't get assigned, panic with some helpful information.\n            _ =\u003e panic!(\"{} is dangling in the gpx file\", edge.name),\n        };\n    }\n\n    Graph {\n        edges,\n        vertices,\n        connection_matrix,\n    }\n}\n\npub fn initialize_from_gpx_file(name: \u0026str) -\u003e Graph {\n    // Open file and read contents to memory\n    let file = File::open(name).unwrap();\n    let reader = BufReader::new(file);\n\n    let gpx_data = gpx::read(reader).unwrap();\n\n    let vertices = gpx_data\n        .waypoints\n        .into_iter()\n        .map(|vertex_data| {\n            // long, lat order is intentional. They are stored in this order in the file.\n            let (long, lat) = vertex_data.point().x_y();\n\n            let height = vertex_data.elevation.unwrap();\n            let name = vertex_data.name.unwrap();\n\n            Vertex::new(name, GPSPointDeg { long, lat, height })\n        })\n        .collect::\u003cVec\u003cVertex\u003e\u003e();\n\n    let edges = gpx_data\n        .tracks\n        .into_iter()\n        .map(|track| {\n            // Indexing at 0 since for every track we are guaranteed to only have move segment.\n            let points = track.segments[0]\n                .points\n                .iter()\n                .map(|waypoint| {\n                    let height = waypoint.elevation.unwrap();\n                    let (long, lat) = waypoint.point().x_y();\n                    let gps = GPSPointDeg { long, lat, height };\n                    let tangential = gps.into_tangential();\n\n                    Point { gps, tangential }\n                })\n                .collect::\u003cVec\u003cPoint\u003e\u003e();\n\n            let name = track.name.unwrap();\n\n            Edge::new(name, points)\n        })\n        .collect::\u003cVec\u003cEdge\u003e\u003e();\n\n    let graph = connect_vertices_with_edges(edges, vertices);\n\n    graph\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":31,"address":[4267424],"length":1,"stats":{"Line":1},"fn_name":"sub"},{"line":33,"address":[4267441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4267568],"length":1,"stats":{"Line":1},"fn_name":"mul"},{"line":43,"address":[4267581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4267680],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":51,"address":[4267705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4267776],"length":1,"stats":{"Line":1},"fn_name":"x"},{"line":55,"address":[4267796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4267824],"length":1,"stats":{"Line":1},"fn_name":"y"},{"line":58,"address":[4267840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4267872],"length":1,"stats":{"Line":1},"fn_name":"z"},{"line":61,"address":[4267888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4267920],"length":1,"stats":{"Line":1},"fn_name":"distance"},{"line":64,"address":[4267934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4267957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4268144],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":80,"address":[4268158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4268317,4268240],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":104,"address":[4268250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4222288,4222301],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":107,"address":[4222333,4222320],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":108,"address":[4268579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4268586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4268627,4269118,4269006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[4269072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4269200,4269152],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":148,"address":[4269172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[4269228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[4269664],"length":1,"stats":{"Line":1},"fn_name":"edge"},{"line":171,"address":[4269685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4269806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[4269856],"length":1,"stats":{"Line":1},"fn_name":"vertices"},{"line":176,"address":[4269877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4269914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[4270016],"length":1,"stats":{"Line":1},"fn_name":"vertices"},{"line":194,"address":[4270038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4270128],"length":1,"stats":{"Line":1},"fn_name":"edges"},{"line":200,"address":[4270145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[4270240,4270300],"length":1,"stats":{"Line":1},"fn_name":"connect_vertices_with_edges"},{"line":205,"address":[4270258,4270323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[4270331,4272504,4270408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[4270602,4270498,4271056,4272388],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[4271122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4271256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[4271363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[4271375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[4271985,4271709,4271395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[4271912,4271983,4271775],"length":1,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[4271860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[4271918,4271829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[4271931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4271625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[4272081,4271689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[4272132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[4272273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[4272398,4271990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4272560,4272627],"length":1,"stats":{"Line":1},"fn_name":"initialize_from_gpx_file"},{"line":251,"address":[4272649,4272586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[4272673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[4272687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[4272778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4222352,4222427],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":261,"address":[4222370,4222454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[4222520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4222579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[4222637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[4272887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4223887,4223776],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":275,"address":[4223902,4223794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[4223408],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":279,"address":[4223441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[4223496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[4223571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4223595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[4223610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[4224008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[4224016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4224079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[4272996],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":79},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","graph","tests.rs"],"content":"use crate::graph;\nuse crate::graph::conversions::{geo_json_string, IntoTangential};\nuse crate::graph::*;\n\n#[test]\nfn initialize_from_gpx_file_test_triangle() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Triangle.gpx\");\n\n    // Asserting the the diagonal of the matrix is none, meaning that no vertex has an edge that\n    // connects to itself. Anything not along the diagonal of the matrix should be populated with a\n    // value in this specific case.\n    for row in 0..graph.connection_matrix.nrows() {\n        for column in 0..graph.connection_matrix.ncols() {\n            if row == column {\n                assert_eq!(graph.connection_matrix[(row, column)], None);\n            } else {\n                assert_ne!(graph.connection_matrix[(row, column)], None);\n            }\n        }\n    }\n}\n\n#[test]\nfn full_graph_no_dangling_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Full School Map.gpx\");\n\n    // Checking that no edge was left unconnected by asserting that the connection matrix is\n    // symmetrical across its diagonal.\n    for row_i in 0..graph.connection_matrix.nrows() {\n        for col_i in 0..graph.connection_matrix.ncols() {\n            if graph.connection_matrix[(row_i, col_i)].is_some() {\n                assert!(graph.connection_matrix[(col_i, row_i)].is_some())\n            }\n        }\n    }\n}\n\n#[test]\nfn initialize_from_gpx_file_single_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n\n    let edges = \u0026graph.edges;\n    let edge = \u0026edges[0];\n\n    assert_eq!(edges.len(), 1);\n    assert_eq!(edge.points.len(), 3);\n    assert_eq!(edge.points[0].gps.long, -112.4484608);\n    assert_eq!(edge.points[0].gps.lat, 34.615871);\n    assert_eq!(edge.points[1].gps.long, -112.4484635);\n    assert_eq!(edge.points[1].gps.lat, 34.6157165);\n    assert_eq!(edge.points[2].gps.long, -112.4484742);\n    assert_eq!(edge.points[2].gps.lat, 34.6155377);\n}\n\n#[test]\nfn graph_to_geo_json_string() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n\n    let json_string = geo_json_string(\u0026graph, \u0026graph);\n    let expected_json_string = r#\"{\"features\":[{\"geometry\":{\"coordinates\":[[-112.4484608,34.615871],[-112.4484635,34.6157165],[-112.4484742,34.6155377]],\"type\":\"LineString\"},\"id\":\"Line 3\",\"properties\":{},\"type\":\"Feature\"},{\"geometry\":{\"coordinates\":[-112.4484608,34.615871],\"type\":\"Point\"},\"id\":\"Point 1\",\"properties\":{},\"type\":\"Feature\"},{\"geometry\":{\"coordinates\":[-112.4484742,34.6155377],\"type\":\"Point\"},\"id\":\"Point 2\",\"properties\":{},\"type\":\"Feature\"}],\"type\":\"FeatureCollection\"}\"#;\n\n    assert_eq!(json_string, expected_json_string);\n}\n\n#[test]\nfn distance() {\n    let origin = graph::TangentialPoint {\n        vector: Vector3::new(0.0, 0.0, 0.0),\n    };\n\n    let point = graph::TangentialPoint {\n        vector: Vector3::new(1.0, 1.0, 1.0),\n    };\n\n    let distance = origin.distance(\u0026point);\n\n    assert_eq!(distance, 3.0_f64.sqrt());\n}\n\n#[test]\nfn into_tangential() {\n    let king_front_entrance = graph::GPSPointDeg {\n        lat: 34.6147979,\n        long: -112.4509615,\n        height: 1582.3,\n    };\n\n    assert_eq!(\n        king_front_entrance.into_tangential(),\n        graph::TangentialPoint {\n            vector: Vector3::new(0.0, 0.0, 0.0)\n        }\n    )\n}\n\n#[test]\nfn tangential_sub() {\n    let origin = \u0026graph::TangentialPoint {\n        vector: Vector3::new(0.0, 0.0, 0.0),\n    };\n    let point = \u0026graph::TangentialPoint {\n        vector: Vector3::new(1.0, 2.0, 3.0),\n    };\n\n    assert_eq!(\n        point - origin,\n        TangentialPoint {\n            vector: Vector3::new(1.0, 2.0, 3.0)\n        }\n    )\n}\n\n#[test]\nfn graph_into_tangential() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    let origin = graph\n        .vertices\n        .iter()\n        .filter(|vertex| vertex.name.contains(\"King Engineering (Front Entrance)\"))\n        .next()\n        .unwrap();\n\n    assert_eq!(\n        origin.point.tangential,\n        TangentialPoint {\n            vector: Vector3::new(0.0, 0.0, 0.0)\n        }\n    );\n}\n\n#[test]\nfn into_tangential_correct_distances() {\n    let king_start_edge = graph::GPSPointDeg {\n        lat: 34.6147979,\n        long: -112.4509615,\n        height: 1582.341,\n    }\n    .into_tangential();\n\n    let king_end_edge = graph::GPSPointDeg {\n        lat: 34.6148752,\n        long: -112.4509389,\n        height: 1581.907,\n    }\n    .into_tangential();\n\n    // Expected distance is about 8.8382m\n    let distance_between_points = king_end_edge.distance(\u0026king_start_edge);\n\n    assert!(distance_between_points \u003e 8.0 \u0026\u0026 distance_between_points \u003c 9.0);\n}\n\n#[test]\nfn edge_initialization() {\n    let points = vec![\n        Point {\n            tangential: TangentialPoint {\n                vector: Vector3::new(0.0, 0.0, 0.0),\n            },\n            gps: GPSPointDeg {\n                lat: -1.0,\n                long: -1.0,\n                height: -1.0,\n            }, // Unimportant for this test\n        },\n        Point {\n            tangential: TangentialPoint {\n                vector: Vector3::new(1.0, 1.0, 1.0),\n            },\n            gps: GPSPointDeg {\n                lat: -1.0,\n                long: -1.0,\n                height: -1.0,\n            }, // Unimportant for this test\n        },\n    ];\n\n    let name = String::from(\"the slight\");\n\n    assert_eq!(\n        Edge::new(name.clone(), points.clone()),\n        Edge {\n            name,\n            points,\n            distance: 3.0_f64.sqrt()\n        }\n    )\n}\n\n#[test]\nfn edge_from_connection_index() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let matrix_index = MatrixIndex {\n        ith: vertex_index_0,\n        jth: vertex_index_1,\n    };\n\n    assert_eq!(\u0026graph.edges[0], matrix_index.edge(\u0026graph));\n}\n\n#[test]\nfn vertices_from_connection_matrix() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let matrix_index = MatrixIndex { ith: 0, jth: 1 };\n\n    assert_eq!(\n        matrix_index.vertices(\u0026graph),\n        (\u0026graph.vertices[0], \u0026graph.vertices[1])\n    )\n}\n","traces":[{"line":6,"address":[4249893,4249856],"length":1,"stats":{"Line":3},"fn_name":"initialize_from_gpx_file_test_triangle"},{"line":7,"address":[4249870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4250025,4250151,4250403,4249908],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[4250408,4250185,4251535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4251220,4250450,4250755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[4250760,4250544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4250463,4251105,4251225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4251621,4251584],"length":1,"stats":{"Line":3},"fn_name":"full_graph_no_dangling_edge"},{"line":25,"address":[4251598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4252068,4251738,4251849,4251636],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[4252073,4252342,4251883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4252107,4252310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4252211,4252312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4224917,4224912],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":40,"address":[4252398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4252436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4252452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4252551,4252513,4252691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4253219,4253068,4252666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4253743,4253183,4253596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4254120,4253707,4254262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4254225,4254787,4254639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4254750,4255306,4255164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4255683,4255831,4255269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4256281,4255794,4256172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[4224944,4224949],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":57,"address":[4256638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4256686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4256699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4256734,4256882,4256836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4224976,4224981],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":68,"address":[4257271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4257343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[4257422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4257457,4257586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4225013,4225008],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":88,"address":[4258021,4258116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4257921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4257973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4257939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4225045,4225040],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":98,"address":[4258478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4258423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4258540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4258527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4258817,4258710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4258604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4258662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4258649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4225077,4225072],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":115,"address":[4259118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4259164,4259257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[4225118,4225104],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":124,"address":[4259445,4259556,4259363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4259408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[4259401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4225205,4225200],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":149,"address":[4259926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[4259965,4260023,4260053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[4225232,4225237],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":156,"address":[4260071,4260503,4261459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[4260219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4260153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4260131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[4260195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4260407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[4260332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4260317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4260380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4260615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4260971,4261134,4261110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4260687,4261477,4260642,4260734],"length":1,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[4260884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[4260781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[4260813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[4260853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[4225264,4225269],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":193,"address":[4261678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4261713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[4261725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4261974,4261761,4261850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[4225296,4225301],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":207,"address":[4262334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4262369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[4262380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4262391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4262575,4262680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[4262428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4262471,4262512],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":89,"coverable":89},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","main.rs"],"content":"// remove this once if the state machine ever gets implemented\n#![allow(dead_code)] \nmod constants;\nmod error;\nmod graph;\nmod network;\nmod path_planning;\nmod states;\nmod traversal;\nmod ui;\n\nuse std::fs;\nuse std::io::Read;\nuse std::io::Write;\nuse std::net::{Ipv4Addr, SocketAddrV4, TcpListener};\nuse std::thread;\nuse std::time::Duration;\n\nuse error::Error;\nuse graph::conversions;\nuse states::States;\nuse ui::TO_UI;\n\n\nfn main() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    {\n        TO_UI.lock().unwrap().write_all(b\"hello\").unwrap();\n    } // Curly braces are here to drop the lock to the UI\n\n    // This function will block waiting for nav, control, and image processing.\n    // Blocking will occur in the order listed.\n    let tcp_streams = network::TcpStreams::setup();\n\n    // Writing the graph back to disk for visual confirmation\n    let geo_json_string = conversions::geo_json_string(\u0026graph, \u0026graph);\n\n    fs::write(\"school_map.geojson\", geo_json_string).unwrap();\n\n    // TODO: Communication here\n    let mut current_state: Result\u003cStates, Error\u003e = Ok(States::Wait);\n\n    loop {\n        match current_state {\n            Err(err) =\u003e unimplemented!(),\n            Ok(state) =\u003e match state {\n                States::PlanPath =\u003e unimplemented!(),\n                States::Wait =\u003e unimplemented!(),\n                States::Traverse =\u003e unimplemented!(),\n                States::Shutdown =\u003e break,\n            },\n        }\n    }\n}\n","traces":[{"line":25,"address":[4403154,4403120],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":26,"address":[4403134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4403220,4403169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4403382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4403402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4403415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4403504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4403580,4403520],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","network","mod.rs"],"content":"use std::io::Write;\nuse std::net::{Ipv4Addr, SocketAddrV4};\n\nuse crate::ui::TO_UI;\nuse cfg_if::cfg_if;\n\ncfg_if! {\n\n    // This can be thought of as a #ifdef in c. In this case, if cargo test is run, then compile the\n    // following code contained within the if statement. This mocks networking code reliant on\n    // hardware.\n    if #[cfg(test)] {\n\n        use mockall::*;\n        use std::io::Result;\n        use std::net::{ToSocketAddrs, SocketAddr};\n\n        mock! {\n            pub TcpStream {}\n        }\n\n        use MockTcpStream as TcpStream;\n\n        mock! {\n            pub TcpListener {\n                fn bind\u003cA: ToSocketAddrs + 'static\u003e(addr: A) -\u003e Result\u003cTcpListener\u003e;\n                fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c()\u003e;\n                fn accept(\u0026self) -\u003e Result\u003c(TcpStream, SocketAddr)\u003e;\n            }\n        }\n\n        use MockTcpListener as TcpListener;\n    }\n\n    else {\n        // cargo run or cargo build was supplied to the terminal. Compile the real code.\n        use std::net::{TcpListener, TcpStream};\n    }\n}\n\nconst GUIDANCE_IP: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1);\nconst CONTROL_PORT: u16 = 31401;\nconst NAV_PORT: u16 = 31402;\nconst IMAG_PROC_PORT: u16 = 31403;\n\npub struct TcpStreams {\n    nav: TcpStream,\n    control: TcpStream,\n    imag_proc: TcpStream,\n}\n\nimpl TcpStreams {\n    pub fn setup() -\u003e Self {\n        TcpStreams {\n            nav: establish_connection(SocketAddrV4::new(GUIDANCE_IP, NAV_PORT)),\n            control: establish_connection(SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT)),\n            imag_proc: establish_connection(SocketAddrV4::new(GUIDANCE_IP, IMAG_PROC_PORT)),\n        }\n    }\n}\n\npub(self) fn establish_connection(socket: SocketAddrV4) -\u003e TcpStream {\n    let tcp_listener = match TcpListener::bind(socket) {\n        Ok(tcp_listener) =\u003e tcp_listener,\n        Err(error) =\u003e {\n            let message = format!(\"Unable to bind to socket: {}\", error);\n\n            // Using unwrap since we are guaranteed to get the mutex. Since we only have one thread.\n            let mut to_ui = TO_UI.lock().unwrap();\n\n            to_ui\n                .write_all(message.as_bytes())\n                .expect(\"Failed to send bind failure to UI\");\n\n            // droping ui lock to avoid poison errors in UI test\n            drop(to_ui);\n            panic!(\"{}\", message)\n        }\n    };\n\n    match tcp_listener.accept() {\n        Ok((tcp_stream, _socket_addr)) =\u003e tcp_stream,\n        Err(error) =\u003e {\n            let message = format!(\"Guidance unable to accept: {}\", error);\n            let mut to_ui = TO_UI.lock().unwrap();\n            to_ui // Acquired mutex\n                .write_all(message.as_bytes()) // Sending message to UI\n                .expect(\"Failed to send tcp accept error message to UI\");\n\n            // Dropping the lock to the UI so other tests wont have poison errors\n            drop(to_ui);\n            panic!(message);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":18,"address":[4230641,4230624,4230640,4230608],"length":1,"stats":{"Line":3},"fn_name":"default"},{"line":24,"address":[4895520,4895237,4895200,4895232,4895504,4895168,4895262,4895185,4895248,4895405,4895208,4895527],"length":1,"stats":{"Line":289},"fn_name":"checkpoint"},{"line":26,"address":[4762907,4759081,4766844,4759355,4767225,4758937,4759677],"length":1,"stats":{"Line":10},"fn_name":null},{"line":53,"address":[4227936],"length":1,"stats":{"Line":1},"fn_name":"setup"},{"line":55,"address":[4227940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4227976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4228016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4228064,4228141],"length":1,"stats":{"Line":3},"fn_name":"establish_connection"},{"line":63,"address":[4228277,4228071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4228279,4228156],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[4228171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4228506,4228187,4228414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4228565,4228629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4228778,4228712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4228735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4228819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4228850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4229154,4228391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4229156,4229044],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[4229060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4229076,4229211,4229309],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[4229376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4229486,4229544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[4229506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4229585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4229616],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":26},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","network","tests.rs"],"content":"use super::*;\nuse crate::ui::*;\nuse std::io;\nuse std::net::IpAddr;\n\n// Some tests are desgined to panic. Unfortuneately, those tests share a state with the UI and can \n// cause other tests designed not to panic, to panic. To remedy this, we run the non-panicing tests in parrallel,\n// and then run the panicing tests in a single thread using the following command.\n//\n// cargo test -- --ignored --test-threads=1\n//\n// Note: this has a negligible affect on runtime when compared to the time to compile tests.\n#[test]\n#[ignore = \"single threaded only\"]\n#[should_panic]\nfn establish_connection_unable_to_bind() {\n    let mut to_ui = TO_UI.lock().unwrap();\n    to_ui\n        .expect_write()\n        .times(1) // An assertion that the write method to UI was called 1 time.\n        .returning(|_| Ok(0));\n\n    let mock_bind = MockTcpListener::bind_context();\n    mock_bind\n        .expect()\n        // The error returned is arbitrary. Just want to make sure that if there is an error,\n        // we notify the UI and Panic\n        .returning(|_: SocketAddrV4| Err(io::Error::last_os_error()));\n\n    let socket = SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT);\n    let _ = establish_connection(socket);\n}\n\n#[test]\nfn establish_connection_able_to_bind_and_accept() {\n    // Aquiring lock as sycronization for mock bind\n    let _ = TO_UI.lock().unwrap();\n\n    // Making acquring the lock succeed regardless if another thread panics\n    // with the lock. a.k.a poisoning.\n    let mock_bind = MockTcpListener::bind_context();\n\n    mock_bind\n        .expect()\n        // Please ignore the type parameter to the input of returning since it is unused to set the\n        // return.\n        .returning(|_: SocketAddrV4| {\n            let mut mock_tcp_listener = MockTcpListener::new();\n\n            mock_tcp_listener.expect_accept().returning(|| {\n                Ok((\n                    MockTcpStream::new(),\n                    SocketAddr::new(IpAddr::V4(GUIDANCE_IP), CONTROL_PORT),\n                ))\n            });\n\n            Ok(mock_tcp_listener)\n        });\n\n    let socket = SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT);\n\n    establish_connection(socket);\n    // Assertion is this path does not panic\n}\n\n#[test]\n#[ignore = \"single threaded only\"]\n#[should_panic]\nfn establish_connection_unable_to_accept() {\n    let mut to_ui = TO_UI.lock().unwrap();\n    to_ui\n        .expect_write()\n        .times(1) // An assertion that the write method to UI was called 1 time.\n        .returning(|_| Ok(0));\n\n    drop(to_ui);\n\n    let mock_bind = MockTcpListener::bind_context();\n    mock_bind\n        .expect()\n        // Please ignore the type parameter to the input of returning since it is unused to set the\n        // return.\n        .returning(|_: SocketAddrV4| {\n            let mut mock_tcp_listener = MockTcpListener::new();\n\n            mock_tcp_listener\n                .expect_accept()\n                .returning(|| Err(io::Error::last_os_error())); // Return stating non-blocking was successful\n\n            Ok(mock_tcp_listener)\n        });\n\n    let socket = SocketAddrV4::new(GUIDANCE_IP, CONTROL_PORT);\n    establish_connection(socket);\n}\n\n\n#[test]\nfn network_setup() {\n    let mut to_ui = TO_UI.lock().unwrap();\n    to_ui\n        .expect_write()\n        .times(0) // Asserting the UI will never be called.\n        .returning(|_| Ok(0));\n\n    let mock_bind = MockTcpListener::bind_context();\n    mock_bind\n        .expect()\n        // Please ignore the type parameter to the input of returning since it is unused to set the\n        // return.\n        .returning(|_: SocketAddrV4| {\n            let mut mock_tcp_listener = MockTcpListener::new();\n\n            mock_tcp_listener.expect_accept().returning(|| {\n                Ok((\n                    MockTcpStream::new(),\n                    SocketAddr::new(IpAddr::V4(GUIDANCE_IP), CONTROL_PORT),\n                ))\n            });\n\n            Ok(mock_tcp_listener)\n        });\n\n    let _tcp_streams = TcpStreams::setup();\n    // Assertion does not panic\n}\n","traces":[{"line":16,"address":[4602677,4602672],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":17,"address":[4479783,4479832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4479914,4479863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4602704,4602725],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":23,"address":[4479938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4479955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4602752,4602764],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":30,"address":[4480010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4480051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4602832,4602837],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":37,"address":[4480227,4480183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4480263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4480278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4603040,4603083],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":48,"address":[4603058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4603103,4602864],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":51,"address":[4602930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4602886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4602891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4603139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4480333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4480374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4480497,4480448],"length":1,"stats":{"Line":4},"fn_name":"establish_connection_unable_to_accept"},{"line":70,"address":[4480512,4480455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[4480551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4603317,4603296],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":76,"address":[4480614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4480639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4480656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4603467,4603424],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":84,"address":[4603442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4603487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4603344,4603356],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":90,"address":[4603523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4480714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4480755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4480953,4480912],"length":1,"stats":{"Line":3},"fn_name":"network_setup"},{"line":100,"address":[4480919,4480965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4481046,4480996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4603680,4603701],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":106,"address":[4481070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4481087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4603904,4603947],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":112,"address":[4603922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4603728,4603967],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":115,"address":[4603794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4603750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4603755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4604003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4481142],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":50},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","path_planning","mod.rs"],"content":"use std::f64;\n\nuse crate::constants::ROBOT_RADIUS;\nuse crate::error::Error;\nuse crate::graph::*;\nuse crate::States;\n\nfn plan_path() -\u003e Result\u003cStates, Error\u003e {\n    // TODO: Send Message to UI\n\n    // TODO: Is robot on edge?\n    unimplemented!();\n}\n\n#[derive(Debug, PartialEq)]\npub struct Path {\n    indices: Vec\u003cMatrixIndex\u003e,\n}\n\nimpl Edges for Path {\n    fn edges\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Edge\u003e {\n        self.indices\n            .iter()\n            .map(|matrix_index| matrix_index.edge(graph))\n            .collect()\n    }\n}\n\nimpl Edges for \u0026Path {\n    fn edges\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Edge\u003e {\n        self.indices\n            .iter()\n            .map(|matrix_index| matrix_index.edge(graph))\n            .collect()\n    }\n}\n\nimpl Vertices for Path {\n    fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Vertex\u003e {\n        // Allocating Memory\n        let mut vertices = Vec::with_capacity(2 * self.indices.len());\n\n        let vertices_start_end = self\n            .indices\n            .iter()\n            .map(|matrix_index| matrix_index.vertices(graph));\n\n        for (vertex_1, vertex_2) in vertices_start_end {\n            vertices.push(vertex_1);\n            vertices.push(vertex_2);\n        }\n\n        // Return the vertex with repeated elements removed\n        vertices.dedup();\n\n        vertices\n    }\n}\n\nimpl Vertices for \u0026Path {\n    fn vertices\u003c'a, 'b\u003e(\u0026'a self, graph: \u0026'b Graph) -\u003e Vec\u003c\u0026'b Vertex\u003e {\n        // Allocating Memory\n        let mut vertices = Vec::with_capacity(2 * self.indices.len());\n\n        let vertices_start_end = self\n            .indices\n            .iter()\n            .map(|matrix_index| matrix_index.vertices(graph));\n\n        for (vertex_1, vertex_2) in vertices_start_end {\n            vertices.push(vertex_1);\n            vertices.push(vertex_2);\n        }\n\n        // Return the vertex with repeated elements removed\n        vertices.dedup();\n\n        vertices\n    }\n}\n\nimpl Graph {\n    /// Returns an error if the robot is not on the edge. Otherwise,\n    /// returns the Matrix index indicating the edge containing the robot.\n    fn closest_edge_to(\u0026self, robot_loc: \u0026TangentialPoint) -\u003e Result\u003cMatrixIndex, Error\u003e {\n        let edges_and_indices = self.edges.iter().enumerate();\n\n        let mut closest_point = TangentialPoint::new(f64::MAX, f64::MAX, f64::MAX);\n        let mut closest_edge_index = None;\n\n        for (edge_index, edge) in edges_and_indices {\n            let point_n = edge.points.iter();\n            let mut point_n_plus_1 = edge.points.iter();\n            point_n_plus_1.next();\n\n            let steps = 80.0;\n            let points_n_n_plus_1 = point_n.zip(point_n_plus_1);\n            for (point_n, point_n_plus_1) in points_n_n_plus_1 {\n                // segmenting points on the line into more points\n                let (start_x, final_x) = (point_n.tangential.x(), point_n_plus_1.tangential.x());\n                let (start_y, final_y) = (point_n.tangential.y(), point_n_plus_1.tangential.y());\n                let (start_z, final_z) = (point_n.tangential.z(), point_n_plus_1.tangential.z());\n\n                let (x_step, y_step, z_step) = (\n                    (final_x - start_x) / steps,\n                    (final_y - start_y) / steps,\n                    (final_z - start_z) / steps,\n                );\n\n                let (mut x, mut y, mut z) = (start_x, start_y, start_z);\n\n                for _ in 0..steps as u32 {\n                    let temp_point = TangentialPoint::new(x, y, z);\n                    let temp_distance_to_robot = temp_point.distance(robot_loc);\n\n                    if temp_distance_to_robot \u003c= ROBOT_RADIUS\n                        \u0026\u0026 temp_distance_to_robot \u003c closest_point.distance(robot_loc)\n                    {\n                        closest_point = temp_point;\n                        closest_edge_index = Some(edge_index);\n                    }\n\n                    x += x_step;\n                    y += y_step;\n                    z += z_step;\n                }\n            }\n        }\n\n        match closest_edge_index {\n            None =\u003e Err(Error::PathPlanningNotOnMap),\n            Some(closest_edge_index) =\u003e self.connection_matrix_index_from(closest_edge_index),\n        }\n    }\n\n    fn connection_matrix_index_from(\u0026self, edge_index: EdgeIndex) -\u003e Result\u003cMatrixIndex, Error\u003e {\n        for row in 0..self.connection_matrix.nrows() {\n            for col in 0..self.connection_matrix.ncols() {\n                if Some(edge_index) == self.connection_matrix[(row, col)] {\n                    return Ok(MatrixIndex { ith: row, jth: col });\n                }\n            }\n        }\n\n        Err(Error::PathPlanningEdgeIndexNotInConnectionMatrix)\n    }\n\n    fn shortest_path(\n        \u0026mut self,\n        start_vertex_index: VertexIndex,\n        end_vertex_index: VertexIndex,\n    ) -\u003e Result\u003cPath, Error\u003e {\n        // Initializing the the graph so all tentative distances are 0\n        // and not parent vertices are set.\n        for vertex in self.vertices.iter_mut() {\n            vertex.tentative_distance = f64::MAX;\n            vertex.visited = false;\n            vertex.parent_vertex_index = None;\n        }\n\n        // Setting the tentative distance of the start vertex to 0\n        self.vertices[start_vertex_index].tentative_distance = 0.0;\n\n        let mut vertex_index = start_vertex_index; // Keeps track of currently visiting vertex\n        let mut nodes_not_visited = self.vertices.len();\n\n        while nodes_not_visited != 0 \u0026\u0026 vertex_index != end_vertex_index {\n            let mut vertex = \u0026mut self.vertices[vertex_index] as *mut Vertex;\n            let connecting_edges = self.connection_matrix.row(vertex_index);\n            let adj_vertices = connecting_edges\n                .iter()\n                .enumerate()\n                .filter(|(_, edge_index)| edge_index.is_some())\n                .map(|(vertex_index, edge_index)| (vertex_index, edge_index.unwrap()));\n\n            for (adj_vertex_index, edge_index) in adj_vertices {\n                let adj_vertex = \u0026mut self.vertices[adj_vertex_index] as *mut Vertex;\n                let connecting_edge = \u0026self.edges[edge_index];\n\n                // Using the unsafe keywords since more than one mutable reference is needed.\n                // One to the currently visiting vertex and the other to the adjacent vertex.\n                unsafe {\n                    if !(*adj_vertex).visited {\n                        let temp_distance = (*vertex).tentative_distance + connecting_edge.distance;\n\n                        if temp_distance \u003c (*adj_vertex).tentative_distance {\n                            (*adj_vertex).tentative_distance = temp_distance;\n                            (*adj_vertex).parent_vertex_index = Some(vertex_index);\n                        }\n                    }\n                }\n            }\n            unsafe {\n                (*vertex).visited = true;\n            }\n            nodes_not_visited -= 1;\n\n            // Selecting the next node to visit\n            let mut min_dist = f64::MAX;\n            for (index, vertex) in self.vertices.iter().enumerate() {\n                if vertex.tentative_distance \u003c min_dist \u0026\u0026 !vertex.visited {\n                    min_dist = vertex.tentative_distance;\n                    vertex_index = index;\n                }\n            }\n        }\n\n        // After completing the while loop, we have either found the shortest path,\n        // or one does not exist. If one exists, then a stack of matrix indices will be outputted\n        // otherwise, an error message will be returned, indicating the path does not exist.\n        let dest_vertex = \u0026self.vertices[end_vertex_index];\n        if dest_vertex.tentative_distance == f64::MAX {\n            return Err(Error::PathPlanningPathDoesNotExist);\n        }\n\n        // Pre allocating memory. Chosen path will never exceed the number of edges in the graph.\n        let mut connection_matrix_indices = Vec::with_capacity(self.edges.len());\n\n        let mut path_vertex_index = end_vertex_index;\n        while path_vertex_index != start_vertex_index {\n            let parent_vertex_index = self.vertices[path_vertex_index]\n                .parent_vertex_index\n                .unwrap();\n            let matrix_index = MatrixIndex {\n                ith: parent_vertex_index,\n                jth: path_vertex_index,\n            };\n\n            connection_matrix_indices.push(matrix_index);\n\n            path_vertex_index = parent_vertex_index;\n        }\n\n        // Reversing the order of the connection matrix index so instructions are given from the\n        // start to the end and not end to start.\n        connection_matrix_indices = connection_matrix_indices.into_iter().rev().collect();\n\n        Ok(Path {\n            indices: connection_matrix_indices,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":8,"address":[4755424],"length":1,"stats":{"Line":0},"fn_name":"plan_path"},{"line":21,"address":[4755456],"length":1,"stats":{"Line":1},"fn_name":"edges"},{"line":22,"address":[4755478,4755536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4265006,4264992],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":30,"address":[4755600],"length":1,"stats":{"Line":0},"fn_name":"edges"},{"line":31,"address":[4755617,4755683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4265040,4265054],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":39,"address":[4755744,4755800],"length":1,"stats":{"Line":1},"fn_name":"vertices"},{"line":41,"address":[4755767,4755820,4756272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4755867,4755936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4265088,4265102],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4755966,4756254,4756153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4756224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4756247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4756146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4756336,4756392],"length":1,"stats":{"Line":0},"fn_name":"vertices"},{"line":63,"address":[4756867,4756359,4756412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4756459,4756531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4265152,4265166],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":70,"address":[4756748,4756849,4756561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4756819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4756842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4756741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4273280],"length":1,"stats":{"Line":1},"fn_name":"closest_edge_to"},{"line":86,"address":[4273306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4273446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4273486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4273693,4274162,4273498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[4273759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4273870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4273937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4273958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4273967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[4274995,4274012,4274167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[4274233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4274375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4274509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4274693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4274655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4274676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4274685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[4274774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4275433,4274856,4275000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[4275023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4275063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4275113,4275169,4275196],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[4275141,4275192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[4275205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4275309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4275367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4275391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[4275415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[4275497,4275480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4275490,4273669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4275438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4275520],"length":1,"stats":{"Line":1},"fn_name":"connection_matrix_index_from"},{"line":137,"address":[4275546,4275930,4275733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[4275772,4276107,4275935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[4275981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[4276117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4275721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[4276303,4276192],"length":1,"stats":{"Line":1},"fn_name":"shortest_path"},{"line":155,"address":[4276226,4276334,4276601,4276514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[4276556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[4276561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4276565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[4276606,4276485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[4276630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4276646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4277670,4276662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[4276789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4276834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[4276865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4265230,4265216],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":174,"address":[4265280,4265306],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":176,"address":[4276949,4277438,4277123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[4277204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[4277256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4277302,4277436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4277320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[4277349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[4277379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[4277384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4277082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[4278555,4277086,4277456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[4277464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4277858,4277481,4277675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[4277744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4277831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[4277850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4277879,4276742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[4277887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4277939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4277962,4277910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[4277996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[4278012,4278258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4278109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4278215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[4278250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4278043,4278279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[4278421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[4278365],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":90,"coverable":107},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","path_planning","tests.rs"],"content":"use crate::graph;\nuse crate::graph::conversions::IntoTangential;\nuse crate::graph::{Edges, MatrixIndex, Vertex, Vertices};\nuse crate::path_planning::*;\nuse crate::Error;\n\n#[test]\nfn robot_on_graph_false_case() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    let middle_of_watson_lake = graph::GPSPointDeg {\n        lat: 34.351398,\n        long: -112.250598,\n        height: 1565.0,\n    }\n    .into_tangential();\n\n    let robot_on_path = graph.closest_edge_to(\u0026middle_of_watson_lake);\n\n    assert_eq!(robot_on_path, Err(Error::PathPlanningNotOnMap));\n}\n\n#[test]\nfn robot_on_graph_true_case() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n    let king_front_entrance_edge_index = graph\n        .edges\n        .iter()\n        .enumerate()\n        .filter(|(_, edge)| edge.name.contains(\"Line 26\"))\n        .map(|(edge_index, _)| edge_index)\n        .next()\n        .unwrap();\n    let expected_matrix_index = graph.connection_matrix_index_from(king_front_entrance_edge_index);\n\n    let king_front_entrance = graph::GPSPointDeg {\n        lat: 34.6147979,\n        long: -112.4509615,\n        height: 1582.3,\n    }\n    .into_tangential();\n\n    let matrix_index = graph.closest_edge_to(\u0026king_front_entrance);\n\n    assert_eq!(expected_matrix_index, matrix_index);\n}\n\n#[test]\nfn robot_not_on_graph_within_radius() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    // Enter lat long in google maps if you wish to verify location of point with our school map\n    let close_point = GPSPointDeg {\n        lat: 34.6148261,\n        long: -112.4508876,\n        height: 1582.0,\n    }\n    .into_tangential();\n\n    let expected_edge = graph.closest_edge_to(\u0026close_point).unwrap().edge(\u0026graph); // Taking the matrix index and returning a reference to the edge\n\n    assert!(expected_edge.name.contains(\"Line 28\"));\n}\n\n#[test]\nfn connection_matrix_index_from_edge_index_single_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let edge_index = 0;\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let matrix_index = graph.connection_matrix_index_from(edge_index);\n\n    assert_eq!(\n        matrix_index,\n        Ok(MatrixIndex {\n            ith: vertex_index_0,\n            jth: vertex_index_1\n        })\n    );\n}\n\n#[test]\nfn connection_matrix_index_from_edge_not_in_connection_matrix() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let faulty_edge_index = 1;\n\n    let matrix_index = graph.connection_matrix_index_from(faulty_edge_index);\n\n    assert_eq!(\n        matrix_index,\n        Err(Error::PathPlanningEdgeIndexNotInConnectionMatrix)\n    );\n}\n\n#[test]\nfn shortest_path_triangle() {\n    // Preview this map to see how the names correspond to each vertex and edge\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Triangle.gpx\");\n\n    // Indices of the vertices get set in the order in which they are read from the gpx file.\n    let start = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 2\"))\n        .unwrap();\n    let end = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 3\"))\n        .unwrap();\n\n    let shortest_path = graph.shortest_path(start, end).unwrap();\n\n    let edges_chosen = shortest_path.edges(\u0026graph);\n    let mut edges_chosen = edges_chosen.iter();\n\n    let vertices_chosen = shortest_path.vertices(\u0026graph);\n    let mut vertices_chosen = vertices_chosen.iter();\n\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 5\"));\n    assert_eq!(edges_chosen.next(), None);\n\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 2\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 3\"));\n    assert_eq!(vertices_chosen.next(), None);\n}\n\n#[test]\nfn shortest_path_school_map() {\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Partial School Map.gpx\");\n\n    let king_front_entrance = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"King Engineering (Front Entrance)\"))\n        .unwrap();\n\n    let library = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Library\"))\n        .unwrap();\n\n    let path = graph.shortest_path(king_front_entrance, library).unwrap();\n\n    let edges_chosen = path.edges(\u0026graph);\n    let mut edges_chosen = edges_chosen.iter();\n\n    let vertices_chosen = path.vertices(\u0026graph);\n    let mut vertices_chosen = vertices_chosen.iter();\n\n    // See map preview or write path to GeoJson to visually confirm assertions\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 26\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 32\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 30\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 35\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 36\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 37\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 38\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 39\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 40\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 41\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 42\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 16\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 17\"));\n    assert_eq!(edges_chosen.next(), None);\n\n    assert!(vertices_chosen\n        .next()\n        .unwrap()\n        .name\n        .contains(\"King Engineering (Front Entrance)\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 25\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 17\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 18\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 28\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 29\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 30\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 31\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 32\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 33\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 34\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 12\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 5\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Library\"));\n    assert_eq!(vertices_chosen.next(), None);\n}\n\n#[test]\nfn shortest_path_no_path() {\n    // Use map preview for visual verification of points chosen for test\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Dijkstra.gpx\");\n    let start_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 12\"))\n        .unwrap();\n    let end_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 16\"))\n        .unwrap();\n\n    let shortest_path = graph.shortest_path(start_vertex_index, end_vertex_index);\n\n    assert_eq!(shortest_path, Err(Error::PathPlanningPathDoesNotExist));\n}\n\n#[test]\nfn shortest_path_dijkstra_graph() {\n    // Use map preview for visual verification of points chosen for test\n    let mut graph = graph::initialize_from_gpx_file(\"src/graph/Test Dijkstra.gpx\");\n    let start_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 12\"))\n        .unwrap();\n    let end_vertex_index = graph\n        .vertices\n        .iter()\n        .position(|vertex| vertex.name.contains(\"Point 5\"))\n        .unwrap();\n\n    let shortest_path = graph\n        .shortest_path(start_vertex_index, end_vertex_index)\n        .unwrap();\n\n    let vertices_chosen = shortest_path.vertices(\u0026graph);\n    let mut vertices_chosen = vertices_chosen.iter();\n\n    let edges_chosen = shortest_path.edges(\u0026graph);\n    let mut edges_chosen = edges_chosen.iter();\n\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 12\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 1\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 17\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 16\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 4\"));\n    assert!(vertices_chosen.next().unwrap().name.contains(\"Point 5\"));\n    assert_eq!(vertices_chosen.next(), None);\n\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 13\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 18\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 19\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 20\"));\n    assert!(edges_chosen.next().unwrap().name.contains(\"Line 14\"));\n}\n\n#[test]\nfn vertices_for_path_single_edge() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Single Edge.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n\n    let path = Path {\n        indices: vec![MatrixIndex {\n            ith: vertex_index_0,\n            jth: vertex_index_1,\n        }],\n    };\n\n    assert_eq!(\n        path.vertices(\u0026graph),\n        vec![\u0026graph.vertices[0], \u0026graph.vertices[1]]\n    )\n}\n\n#[test]\nfn vertices_for_path_triangle() {\n    let graph = graph::initialize_from_gpx_file(\"src/graph/Test Triangle.gpx\");\n    let vertex_index_0 = 0;\n    let vertex_index_1 = 1;\n    let vertex_index_2 = 2;\n\n    let path = Path {\n        indices: vec![\n            MatrixIndex {\n                ith: vertex_index_0,\n                jth: vertex_index_1,\n            },\n            MatrixIndex {\n                ith: vertex_index_1,\n                jth: vertex_index_2,\n            },\n        ],\n    };\n\n    let expected_vertices: Vec\u003c\u0026Vertex\u003e = graph.vertices.iter().collect();\n\n    assert_eq!(path.vertices(\u0026graph), expected_vertices)\n}\n","traces":[{"line":8,"address":[4565648,4565682],"length":1,"stats":{"Line":3},"fn_name":"robot_on_graph_false_case"},{"line":9,"address":[4565662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4565740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4565759,4565874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4566208,4566245],"length":1,"stats":{"Line":3},"fn_name":"robot_on_graph_true_case"},{"line":25,"address":[4566222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4566260,4566363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4646320,4646334],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":31,"address":[4646432,4646450],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":34,"address":[4566503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4566559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4566685,4566574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4567058,4567024],"length":1,"stats":{"Line":3},"fn_name":"robot_not_on_graph_within_radius"},{"line":50,"address":[4567038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4567116,4567135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4567306,4567231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4567376,4567410],"length":1,"stats":{"Line":3},"fn_name":"connection_matrix_index_from_edge_index_single_edge"},{"line":67,"address":[4567390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4567425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4567437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4567449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4567478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4567557,4567659,4567680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[4567485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4568050,4568016],"length":1,"stats":{"Line":3},"fn_name":"connection_matrix_index_from_edge_not_in_connection_matrix"},{"line":85,"address":[4568030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4568065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4568095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4568232,4568102,4568211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4568613,4568576],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_triangle"},{"line":99,"address":[4568590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4568721,4568636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[4646592,4646606],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":107,"address":[4568842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[4646672,4646686],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":113,"address":[4569049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4569113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4569231,4569185,4569128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[4569279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4569294,4569382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4569571,4569414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4569556,4569758,4569612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[4570260,4569740,4570118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[4570293,4570408,4570245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4570446,4570572,4570396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[4571024,4571061],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_school_map"},{"line":131,"address":[4571038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4571084,4571169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[4646784,4646798],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":139,"address":[4571290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4646864,4646878],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":145,"address":[4571497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4571561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[4571576,4571633,4571679],"length":1,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[4571727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[4571830,4571742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[4572019,4571862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[4572052,4572194,4572004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[4572369,4572227,4572179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[4572354,4572402,4572544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4572719,4572529,4572577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[4572894,4572704,4572752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[4573069,4572879,4572927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[4573244,4573054,4573102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[4573229,4573277,4573419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[4573404,4573594,4573452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[4573579,4573627,4573769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[4573802,4573944,4573754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[4573929,4574119,4573977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4574104,4574306,4574160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[4574808,4574666,4574288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[4574793,4574983,4574841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[4574968,4575016,4575158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[4575333,4575143,4575191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[4575318,4575366,4575508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[4575683,4575493,4575541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[4575858,4575716,4575668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[4575891,4575843,4576033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4576208,4576066,4576018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[4576241,4576193,4576383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[4576416,4576558,4576368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[4576543,4576591,4576733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[4576908,4576766,4576718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[4576941,4577056,4576893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4577220,4577094,4577044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4577664,4577701],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_no_path"},{"line":193,"address":[4577678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4577724,4577809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4646976,4646990],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":199,"address":[4577930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4647070,4647056],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":205,"address":[4578113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[4578123,4578261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4578677,4578640],"length":1,"stats":{"Line":3},"fn_name":"shortest_path_dijkstra_graph"},{"line":213,"address":[4578654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[4578785,4578700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[4647168,4647182],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":219,"address":[4578906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[4647262,4647248],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":225,"address":[4579113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4579177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4579295,4579192,4579249],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[4579343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[4579358,4579446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[4579635,4579478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4579668,4579620,4579810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[4579795,4579843,4579985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[4580160,4580018,4579970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[4580145,4580335,4580193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[4580368,4580510,4580320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[4580495,4580551,4580697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4581199,4580679,4581057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[4581232,4581371,4581184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[4581516,4581359,4581404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[4581549,4581661,4581504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[4581801,4581694,4581649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[4582002,4581968],"length":1,"stats":{"Line":3},"fn_name":"vertices_for_path_single_edge"},{"line":252,"address":[4581982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[4582017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[4582029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[4582051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[4582405,4582537,4582561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[4582194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[4582344,4582270,4582913,4582211],"length":1,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[4583104,4583138],"length":1,"stats":{"Line":3},"fn_name":"vertices_for_path_triangle"},{"line":271,"address":[4583118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[4583153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4583165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4583177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4583199,4583252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[4583374,4583451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[4583599,4583479,4583685],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":132,"coverable":132},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","states.rs"],"content":"#[derive(PartialEq, Debug)]\npub enum States {\n    Wait,\n    PlanPath,\n    Traverse,\n    Shutdown,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","traversal","mod.rs"],"content":"// The following is a link to our proof of concept\n//\n// https://www.geogebra.org/classic/jwwnnxy6\n\nuse crate::graph::TangentialPoint;\nuse cfg_if::cfg_if;\n\n// Determines when we increment to our next point. Once we have traversed the\n// percentage of 1 - OFFSET_FACTOR, we increment the point we are attempting to\n// traverse to.\ncfg_if! {\n    if #[cfg(test)] { // So unit tests never break\n        const OFFSET_FACTOR: f64 = 0.09;\n    }\n    else { // Here we can tweek this factor when experimenting with the robot.\n        const OFFSET_FACTOR: f64 = 0.09;\n    }\n}\n\npub struct ProximityLine {\n    m: f64,\n    b: f64,\n}\n\nimpl ProximityLine {\n    // Create the proximity line given the robot location and the next point we\n    // wish to traverse to. Be sure to consult the proof of concept to get a\n    // visual understanding for what this function is doing.\n    //\n    // https://www.geogebra.org/classic/jwwnnxy6\n    pub fn new(robot_loc: \u0026TangentialPoint, next_point: \u0026TangentialPoint) -\u003e Self {\n        // The vector that goes from our robot to the next point to traverse.\n        let ideal_traversal_v = next_point - robot_loc;\n\n        // The amount we move back from next point to place our proximity line.\n        let proximity_offset = ideal_traversal_v * OFFSET_FACTOR;\n\n        // A point that will lie on the proximity line\n        let proximity_point = next_point - \u0026proximity_offset;\n\n        // The slope of the proximity line. Garunteed to be perpendicular to the\n        // line that goes from our robot to the next desired point\n        let m = (-1.0) * ideal_traversal_v.x() / ideal_traversal_v.y();\n\n        // The y intercept of our line\n        let b = proximity_point.y() - m * proximity_point.x();\n\n        ProximityLine { m, b }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":31,"address":[4757184],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":33,"address":[4757207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4757243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4757300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4757323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4757404],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","traversal","tests.rs"],"content":"use super::*;\n\n// TO confirm, use the geogebra tool and put the robot_loc and next point in the\n// locations corresponding to the test.\n//\n// https://www.geogebra.org/classic/jwwnnxy6\n\n#[test]\nfn new_proximity_line() {\n    let prev_point = TangentialPoint::new(0.0, 1.2, 0.0);\n    let next_point = TangentialPoint::new(2.0, 1.0, 0.0);\n\n    let proximity_line = ProximityLine::new(\u0026prev_point, \u0026next_point);\n\n    assert!(\n        proximity_line.m \u003e 9.9\n            \u0026\u0026 proximity_line.m \u003c 10.1\n            \u0026\u0026 proximity_line.b \u003e -17.19\n            \u0026\u0026 proximity_line.b \u003c -17.17\n    );\n}\n\n#[test]\nfn horizontal_proximity_line() {\n    let prev_point = TangentialPoint::new(0.0, 1.0, 0.0);\n    let next_point = TangentialPoint::new(0.0, 3.0, 0.0);\n\n    let proximity_line = ProximityLine::new(\u0026prev_point, \u0026next_point);\n\n    assert_eq!(proximity_line.m, 0.0);\n}\n\n#[test]\nfn vertical_proximity_line() {\n    use std::f64;\n\n    let prev_point = TangentialPoint::new(0.0, 1.0, 0.0);\n    let next_point = TangentialPoint::new(2.0, 1.0, 0.0);\n\n    let proximity_line = ProximityLine::new(\u0026prev_point, \u0026next_point);\n\n    assert_eq!(proximity_line.m, f64::NEG_INFINITY);\n}\n","traces":[{"line":9,"address":[4211376],"length":1,"stats":{"Line":3},"fn_name":"new_proximity_line"},{"line":10,"address":[4211388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4211429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4211442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4211646,4211676,4211539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4211535,4211628,4211495,4211583,4211551],"length":1,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[4211624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[4211579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4211531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4211680],"length":1,"stats":{"Line":3},"fn_name":"horizontal_proximity_line"},{"line":25,"address":[4211695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4211728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4211763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4211900,4211786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4212192],"length":1,"stats":{"Line":3},"fn_name":"vertical_proximity_line"},{"line":37,"address":[4212207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4212248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4212271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[4212294,4212408],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","sean","rust","mr-fusion-capstone","guidance","rust_code","src","ui.rs"],"content":"use cfg_if::cfg_if;\nuse lazy_static::*;\n\nuse std::sync::Mutex;\n\npub const PATH_TO_UI_PIPE: \u0026str = \"to_ui\";\npub const PATH_FROM_UI_PIPE: \u0026str = \"from_ui\";\n\ncfg_if! {\n    if #[cfg(test)] {\n        use mockall::*;\n        use std::io;\n        use std::io::Write;\n\n        mock! {\n            pub File {}\n            trait Write {\n                fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e;\n                fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e;\n            }\n        }\n\n        lazy_static! {\n            // Opening the pipe with write permissions will block until the reader opens the file as well.\n            pub static ref TO_UI: Mutex\u003cMockFile\u003e = Mutex::new(MockFile::new());\n        }\n\n        lazy_static! {\n            pub static ref FROM_UI: Mutex\u003cMockFile\u003e = Mutex::new(MockFile::new());\n        }\n    }\n    else {\n        use std::fs::{OpenOptions, File};\n\n        lazy_static! {\n            // Opening the pipe with write permissions will block until the reader opens the file as well.\n            pub static ref TO_UI: Mutex\u003cFile\u003e = Mutex::new(OpenOptions::new()\n                .append(true)\n                .create_new(false)\n                .open(PATH_TO_UI_PIPE)\n                .unwrap() // Not sure how we want to handle an error here.\n            );\n        }\n\n        lazy_static! {\n            pub static ref FROM_UI: Mutex\u003cFile\u003e = Mutex::new(OpenOptions::new()\n                .read(true)\n                .open(PATH_FROM_UI_PIPE)\n                .unwrap() // Not sure how we want to handle an error here.\n            );\n        }\n    }\n}\n","traces":[{"line":15,"address":[4237435,4236732,4236567,4234846,4236720,4237216,4233920,4234914,4236272,4237324,4233901,4236426,4236051,4237230,4237408,4233935,4234832,4236284,4236499,4235836,4236119,4235570,4234864,4234873,4234944,4237168,4237182,4237248,4234055,4235824,4234975,4236947,4233888,4235978,4234896,4237015,4236874,4234550],"length":1,"stats":{"Line":95},"fn_name":"{{closure}}"},{"line":18,"address":[4237233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4440823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4443159],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":4}]};
    </script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>